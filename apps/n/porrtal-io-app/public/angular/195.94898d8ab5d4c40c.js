/*
Copyright 2022 Comcast Cable Communications Management, LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
"use strict";(self.webpackChunka_porrtal_io_app=self.webpackChunka_porrtal_io_app||[]).push([[195],{90195:(xt,Be,C)=>{C.r(Be),C.d(Be,{default:()=>yt});var le=C(15861),me=C(10699),Y=C(919),He=C(62208),v=C(86575);function Ke(c){return!(c<11904)&&(c>=12704&&c<=12735||c>=12544&&c<=12591||c>=65072&&c<=65103||c>=63744&&c<=64255||c>=13056&&c<=13311||c>=11904&&c<=12031||c>=12736&&c<=12783||c>=12288&&c<=12351||c>=13312&&c<=19903||c>=19968&&c<=40959||c>=12800&&c<=13055||c>=65280&&c<=65519||c>=12352&&c<=12447||c>=12272&&c<=12287||c>=12032&&c<=12255||c>=12784&&c<=12799||c>=12448&&c<=12543||c>=65040&&c<=65055||c>=42128&&c<=42191||c>=40960&&c<=42127)}function We(c){switch(c){case 10:case 32:case 38:case 40:case 41:case 43:case 45:case 47:case 173:case 183:case 8203:case 8208:case 8211:case 8231:return!0}return!1}function be(c){switch(c){case 9:case 10:case 11:case 12:case 13:case 32:return!0}return!1}var we=C(84439);const Z=24;class De{constructor(e,t,r,i,n,a,o){this._glyphItems=e,this._maxWidth=t,this._lineHeight=r,this._letterSpacing=i,this._hAnchor=n,this._vAnchor=a,this._justify=o}getShaping(e,t,r){const i=this._letterSpacing,n=this._lineHeight,a=this._justify,o=this._maxWidth,l=[];let u=0,f=0;const d=e.length;for(let p=0;p<d;p++){const M=e.charCodeAt(p),B=r&&(746===(c=M)||747===c||!(c<4352)&&(c>=12704&&c<=12735||c>=12544&&c<=12591||c>=65072&&c<=65103&&!(c>=65097&&c<=65103)||c>=63744&&c<=64255||c>=13056&&c<=13311||c>=11904&&c<=12031||c>=12736&&c<=12783||c>=12288&&c<=12351&&!(c>=12296&&c<=12305||c>=12308&&c<=12319||12336===c)||c>=13312&&c<=19903||c>=19968&&c<=40959||c>=12800&&c<=13055||c>=12592&&c<=12687||c>=43360&&c<=43391||c>=55216&&c<=55295||c>=4352&&c<=4607||c>=44032&&c<=55215||c>=12352&&c<=12447||c>=12272&&c<=12287||c>=12688&&c<=12703||c>=12032&&c<=12255||c>=12784&&c<=12799||c>=12448&&c<=12543&&12540!==c||c>=65280&&c<=65519&&!(65288===c||65289===c||65293===c||c>=65306&&c<=65310||65339===c||65341===c||65343===c||c>=65371&&c<=65503||65507===c||c>=65512&&c<=65519)||c>=65104&&c<=65135&&!(c>=65112&&c<=65118||c>=65123&&c<=65126)||c>=5120&&c<=5759||c>=6320&&c<=6399||c>=65040&&c<=65055||c>=19904&&c<=19967||c>=40960&&c<=42127||c>=42128&&c<=42191));let I;for(const P of this._glyphItems)if(I=P[M],I)break;l.push({codePoint:M,x:u,y:f,vertical:B,glyphMosaicItem:I}),I&&(u+=I.metrics.advance+i)}var c;let h=u;o>0&&(h=u/Math.max(1,Math.ceil(u/o)));const y=e.includes("\u200b"),g=[];for(let p=0;p<d-1;p++){const M=l[p].codePoint,B=Ke(M);if(We(M)||B){let I=0;if(10===M)I-=1e4;else if(B&&y)I+=150;else{40!==M&&65288!==M||(I+=50);const P=l[p+1].codePoint;41!==P&&65289!==P||(I+=50)}g.push(this._buildBreak(p+1,l[p].x,h,g,I,!1))}}const m=this._optimalBreaks(this._buildBreak(d,u,h,g,0,!0));let T=0;const x=t?-n:n;let _=0;for(let p=0;p<m.length;p++){const M=m[p];let B=_;for(;B<M&&be(l[B].codePoint);)l[B].glyphMosaicItem=null,++B;let I=M-1;for(;I>B&&be(l[I].codePoint);)l[I].glyphMosaicItem=null,--I;if(B<=I){const P=l[B].x;for(let b=B;b<=I;b++)l[b].x-=P,l[b].y=f;let L=l[I].x;l[I].glyphMosaicItem&&(L+=l[I].glyphMosaicItem.metrics.advance),T=Math.max(L,T),a&&this._applyJustification(l,B,I)}_=M,f+=x}if(l.length>0){const p=m.length-1,M=(a-this._hAnchor)*T;let B=(-this._vAnchor*(p+1)+.5)*n;t&&p&&(B+=p*n);for(const I of l)I.x+=M,I.y+=B}return l.filter(p=>p.glyphMosaicItem)}static getTextBox(e,t){if(!e.length)return null;let r=1/0,i=1/0,n=0,a=0;for(const o of e){const u=o.x,f=o.y-17,d=u+o.glyphMosaicItem.metrics.advance,h=f+t;r=Math.min(r,u),n=Math.max(n,d),i=Math.min(i,f),a=Math.max(a,h)}return{x:r,y:i,width:n-r,height:a-i}}static getBox(e){if(!e.length)return null;let t=1/0,r=1/0,i=0,n=0;for(const a of e){const{height:o,left:l,top:u,width:f}=a.glyphMosaicItem.metrics,d=a.x,h=a.y-(o-Math.abs(u)),y=d+f+l,g=h+o;t=Math.min(t,d),i=Math.max(i,y),r=Math.min(r,h),n=Math.max(n,g)}return{x:t,y:r,width:i-t,height:n-r}}static addDecoration(e,t){const r=e.length;if(0===r)return;let n=e[0].x+e[0].glyphMosaicItem.metrics.left,a=e[0].y;for(let l=1;l<r;l++){const u=e[l];if(u.y!==a){const f=e[l-1].x+e[l-1].glyphMosaicItem.metrics.left+e[l-1].glyphMosaicItem.metrics.width;e.push({codePoint:0,x:n,y:a+t-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new we.Z(4,0,4,8),metrics:{width:f-n,height:8,left:0,top:0,advance:0},page:0,code:0}}),a=u.y,n=u.x+u.glyphMosaicItem.metrics.left}}const o=e[r-1].x+e[r-1].glyphMosaicItem.metrics.left+e[r-1].glyphMosaicItem.metrics.width;e.push({codePoint:0,x:n,y:a+t-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new we.Z(4,0,4,8),metrics:{width:o-n,height:8,left:0,top:0,advance:0},page:0,code:0}})}_breakScore(e,t,r,i){const n=(e-t)*(e-t);return i?e<t?n/2:2*n:n+Math.abs(r)*r}_buildBreak(e,t,r,i,n,a){let o=null,l=this._breakScore(t,r,n,a);for(const u of i){const d=this._breakScore(t-u.x,r,n,a)+u.score;d<=l&&(o=u,l=d)}return{index:e,x:t,score:l,previousBreak:o}}_optimalBreaks(e){return e?this._optimalBreaks(e.previousBreak).concat(e.index):[]}_applyJustification(e,t,r){const i=e[r],a=(i.x+(i.vertical?Z:i.glyphMosaicItem?i.glyphMosaicItem.metrics.advance:0))*this._justify;for(let o=t;o<=r;o++)e[o].x-=a}}var Ve=C(47132),V=C(1268),E=C(97938);const q=.5;class he{constructor(e,t,r=0,i=-1,n=q){this.x=e,this.y=t,this.angle=r,this.segment=i,this.minzoom=n}}class ce{constructor(e,t,r,i,n,a=q,o=v.B1){this.anchor=e,this.labelAngle=t,this.glyphAngle=r,this.page=i,this.alternateVerticalGlyph=n,this.minzoom=a,this.maxzoom=o}}class ve{constructor(e,t,r,i,n,a,o,l,u,f,d,h){this.tl=e,this.tr=t,this.bl=r,this.br=i,this.mosaicRect=n,this.labelAngle=a,this.minAngle=o,this.maxAngle=l,this.anchor=u,this.minzoom=f,this.maxzoom=d,this.page=h}}class Ae{constructor(e){this.shapes=e}}class je{getIconPlacement(e,t,r){const i=new E.E(e.x,e.y),n=r.rotationAlignment===V.aF.MAP,a=r.keepUpright;let o=r.rotate*v.DT;n&&(o+=e.angle);const l=new Ae([]);return r.allowOverlap&&r.ignorePlacement||!Ve.Bf||(l.iconColliders=[]),this._addIconPlacement(l,i,t,r,o),n&&a&&this._addIconPlacement(l,i,t,r,o+v.JJ),l}_addIconPlacement(e,t,r,i,n){const a=r.pixelRatio,o=r.width/a,l=r.height/a,u=i.offset;let f=u[0],d=u[1];switch(i.anchor){case V.nR.CENTER:f-=o/2,d-=l/2;break;case V.nR.LEFT:d-=l/2;break;case V.nR.RIGHT:f-=o,d-=l/2;break;case V.nR.TOP:f-=o/2;break;case V.nR.BOTTOM:f-=o/2,d-=l;break;case V.nR.TOP_LEFT:break;case V.nR.BOTTOM_LEFT:d-=l;break;case V.nR.TOP_RIGHT:f-=o;break;case V.nR.BOTTOM_RIGHT:f-=o,d-=l}const h=r.rect,y=2/a,g=f-y,m=d-y,T=g+h.width/a,x=m+h.height/a,_=new E.E(g,m),p=new E.E(T,x),M=new E.E(g,x),B=new E.E(T,m);if(0!==n){const P=Math.cos(n),L=Math.sin(n);_.rotate(P,L),p.rotate(P,L),M.rotate(P,L),B.rotate(P,L)}const I=new ve(_,B,M,p,h,n,0,256,t,q,v.B1,0);if(e.shapes.push(I),(!i.allowOverlap||!i.ignorePlacement)&&Ve.Bf){const P=i.size,L=i.padding;e.iconColliders.push({xTile:t.x,yTile:t.y,dxPixels:f*P-L,dyPixels:d*P-L,hard:!i.optional,partIndex:0,width:o*P+2*L,height:l*P+2*L,angle:n,minLod:q,maxLod:v.B1})}}getTextPlacement(e,t,r,i){const n=new E.E(e.x,e.y),a=i.rotate*v.DT,o=i.rotationAlignment===V.aF.MAP,l=i.keepUpright,u=i.padding;let f=q;const d=o?e.angle:0,h=e.segment>=0&&o,y=i.allowOverlap&&i.ignorePlacement?null:[],g=[],T=!h;let x=Number.POSITIVE_INFINITY,_=Number.NEGATIVE_INFINITY,p=x,M=_;const B=(h||o)&&l,I=i.size/Z;let P=!1;for(const w of t)if(w.vertical){P=!0;break}let L,b=0,D=0;if(!h&&P){const w=De.getTextBox(t,i.lineHeight*Z);switch(i.anchor){case V.nR.LEFT:b=w.height/2,D=-w.width/2;break;case V.nR.RIGHT:b=-w.height/2,D=w.width/2;break;case V.nR.TOP:b=w.height/2,D=w.width/2;break;case V.nR.BOTTOM:b=-w.height/2,D=-w.width/2;break;case V.nR.TOP_LEFT:b=w.height;break;case V.nR.BOTTOM_LEFT:D=-w.width;break;case V.nR.TOP_RIGHT:D=w.width;break;case V.nR.BOTTOM_RIGHT:b=-w.height}}b+=i.offset[0]*Z,D+=i.offset[1]*Z;for(const w of t){const S=w.glyphMosaicItem;if(!S||S.rect.isEmpty)continue;const k=S.rect,R=S.metrics,U=S.page;if(y&&T){if(void 0!==L&&L!==w.y){let F,N,W,j;P?(F=-M+b,N=x+D,W=M-p,j=_-x):(F=x+b,N=p+D,W=_-x,j=M-p),y.push({xTile:e.x,yTile:e.y,dxPixels:F*I-u,dyPixels:N*I-u,hard:!i.optional,partIndex:1,width:W*I+2*u,height:j*I+2*u,angle:a,minLod:q,maxLod:v.B1}),x=Number.POSITIVE_INFINITY,_=Number.NEGATIVE_INFINITY,p=x,M=_}L=w.y}const ee=[];if(h){const N=(w.x+R.left-4+.5*S.metrics.width)*I*8;if(f=this._placeGlyph(e,f,N,r,e.segment,1,w.vertical,U,ee),l&&(f=this._placeGlyph(e,f,N,r,e.segment,-1,w.vertical,U,ee)),f>=2)break}else ee.push(new ce(n,d,d,U,!1)),o&&l&&ee.push(new ce(n,d+v.JJ,d+v.JJ,U,!1));const H=w.x+R.left,X=w.y-17-R.top,te=H+R.width,Te=X+R.height;let z,K,fe,de,se,ye,Ne,Ge;!h&&P?w.vertical?(z=new E.E(-((X+Te)/2+R.width/2)-4+b,(H+te)/2-R.height/2-4+D),K=new E.E(z.x+k.width,z.y+k.height),fe=new E.E(z.x,K.y),de=new E.E(K.x,z.y)):(z=new E.E(4-X+b,H-4+D),K=new E.E(z.x-k.height,z.y+k.width),fe=new E.E(K.x,z.y),de=new E.E(z.x,K.y)):(z=new E.E(H-4+b,X-4+D),K=new E.E(z.x+k.width,z.y+k.height),fe=new E.E(z.x,K.y),de=new E.E(K.x,z.y));for(const F of ee){let N,W,j,Q;F.alternateVerticalGlyph?(se||(se=new E.E((H+te)/2+b-R.height/2-4,(X+Te)/2+D+R.width/2+4),ye=new E.E(se.x+k.height,se.y-k.width),Ne=new E.E(ye.x,se.y),Ge=new E.E(se.x,ye.y)),N=se,W=Ne,j=Ge,Q=ye):(N=z,W=fe,j=de,Q=K);const xe=X,Pe=Te,ge=F.glyphAngle+a;if(0!==ge){const $=Math.cos(ge),pe=Math.sin(ge);N=N.clone(),W=W.clone(),j=j.clone(),Q=Q.clone(),N.rotate($,pe),Q.rotate($,pe),W.rotate($,pe),j.rotate($,pe)}let ae=0,oe=256;h&&P?w.vertical?F.alternateVerticalGlyph?(ae=32,oe=96):(ae=224,oe=32):(ae=224,oe=96):(ae=192,oe=64),g.push(new ve(N,j,W,Q,k,F.labelAngle,ae,oe,F.anchor,F.minzoom,F.maxzoom,F.page)),!y||B&&!this._legible(F.labelAngle)||(T?(H<x&&(x=H),xe<p&&(p=xe),te>_&&(_=te),Pe>M&&(M=Pe)):F.minzoom<2&&y.push({xTile:e.x,yTile:e.y,dxPixels:(H+b)*I-u,dyPixels:(xe+b)*I-u,hard:!i.optional,partIndex:1,width:(te-H)*I+2*u,height:(Pe-xe)*I+2*u,angle:ge,minLod:F.minzoom,maxLod:F.maxzoom}))}}if(f>=2)return null;if(y&&T){let w,S,k,R;P?(w=-M+b,S=x+D,k=M-p,R=_-x):(w=x+b,S=p+D,k=_-x,R=M-p),y.push({xTile:e.x,yTile:e.y,dxPixels:w*I-u,dyPixels:S*I-u,hard:!i.optional,partIndex:1,width:k*I+2*u,height:R*I+2*u,angle:a,minLod:q,maxLod:v.B1})}const A=new Ae(g);return y&&y.length>0&&(A.textColliders=y),A}_legible(e){const t=(0,v.Or)(e);return t<65||t>=193}_placeGlyph(e,t,r,i,n,a,o,l,u){let f=a;const d=f<0?(0,v.DQ)(e.angle+v.JJ,v._U):e.angle;let h=0;r<0&&(f*=-1,r*=-1,h=v.JJ),f>0&&++n;let y=new E.E(e.x,e.y),g=i[n],m=v.B1;if(i.length<=n)return m;for(;;){const T=g.x-y.x,x=g.y-y.y,_=Math.sqrt(T*T+x*x),p=Math.max(r/_,t),I=(0,v.DQ)(Math.atan2(x/_,T/_)+h,v._U);if(u.push(new ce(y,d,I,l,!1,p,m)),o&&u.push(new ce(y,d,I,l,!0,p,m)),p<=t)return p;y=g.clone();do{if(i.length<=(n+=f)||n<0)return p;g=i[n]}while(y.isEqual(g));let P=g.x-y.x,L=g.y-y.y;const b=Math.sqrt(P*P+L*L);P*=_/b,L*=_/b,y.x-=P,y.y-=L,m=p}}}var ie,c,Ye=C(24192),ke=C(58774);(c=ie||(ie={}))[c.moveTo=1]="moveTo",c[c.lineTo=2]="lineTo",c[c.close=7]="close";class Je{constructor(e,t){this.values={};const r=t.keys,i=t.values;for(;e.next();)switch(e.tag()){case 1:this.id=e.getUInt64();break;case 2:{const n=e.getMessage(),a=this.values;for(;!n.empty();){const o=n.getUInt32(),l=n.getUInt32();a[r[o]]=i[l]}n.release();break}case 3:this.type=e.getUInt32();break;case 4:this._pbfGeometry=e.getMessage();break;default:e.skip()}}getGeometry(e){if(void 0!==this._geometry)return this._geometry;if(!this._pbfGeometry)return null;const t=this._pbfGeometry;let r,i;this._pbfGeometry=null,e?e.reset(this.type):r=[];let n,a=ie.moveTo,o=0,l=0,u=0;for(;!t.empty();){if(0===o){const f=t.getUInt32();a=7&f,o=f>>3}switch(o--,a){case ie.moveTo:l+=t.getSInt32(),u+=t.getSInt32(),e?e.moveTo(l,u):(i&&r.push(i),i=[],i.push(new E.E(l,u)));break;case ie.lineTo:l+=t.getSInt32(),u+=t.getSInt32(),e?e.lineTo(l,u):i.push(new E.E(l,u));break;case ie.close:e?e.close():i&&!i[0].equals(l,u)&&i.push(i[0].clone());break;default:throw t.release(),new Error("Invalid path operation")}}return e?n=e.result():(i&&r.push(i),n=r),t.release(),this._geometry=n,n}}var O=C(36243);class re extends O.Z{constructor(){super(12)}add(e,t,r){const i=this.array;i.push(e),i.push(t),i.push(r)}}class Ie{constructor(e){for(this.extent=4096,this.keys=[],this.values=[],this._pbfLayer=e.clone();e.next();)switch(e.tag()){case 1:this.name=e.getString();break;case 3:this.keys.push(e.getString());break;case 4:this.values.push(e.processMessage(Ie._parseValue));break;case 5:this.extent=e.getUInt32();break;default:e.skip()}}getData(){return this._pbfLayer}static _parseValue(e){for(;e.next();)switch(e.tag()){case 1:return e.getString();case 2:return e.getFloat();case 3:return e.getDouble();case 4:return e.getInt64();case 5:return e.getUInt64();case 6:return e.getSInt64();case 7:return e.getBool();default:e.skip()}return null}}class Xe extends O.Z{constructor(e){super(e)}add(e,t,r,i,n,a,o,l,u,f,d,h){const y=this.array;let g=O.Z.i1616to32(e,t);y.push(g);const m=31;g=O.Z.i8888to32(Math.round(m*r),Math.round(m*i),Math.round(m*n),Math.round(m*a)),y.push(g),g=O.Z.i8888to32(Math.round(m*o),Math.round(m*l),Math.round(m*u),Math.round(m*f)),y.push(g),g=O.Z.i1616to32(d,0),y.push(g),h&&y.push(...h)}}class Qe extends O.Z{constructor(e){super(e)}add(e,t,r){const i=this.array;i.push(O.Z.i1616to32(e,t)),r&&i.push(...r)}}class $e extends O.Z{constructor(e){super(e)}add(e,t,r,i,n,a,o){const l=this.array,u=this.index;let f=O.Z.i1616to32(e,t);return l.push(f),f=O.Z.i8888to32(Math.round(15*r),Math.round(15*i),n,a),l.push(f),o&&l.push(...o),u}}class Re extends O.Z{constructor(e){super(e)}add(e,t,r,i,n,a,o,l,u,f,d,h){const y=this.array;let g=O.Z.i1616to32(e,t);y.push(g),g=O.Z.i1616to32(Math.round(8*r),Math.round(8*i)),y.push(g),g=O.Z.i8888to32(n/4,a/4,l,u),y.push(g),g=O.Z.i8888to32(0,(0,v.Or)(o),10*f,Math.min(10*d,255)),y.push(g),h&&y.push(...h)}}class qe extends O.Z{constructor(e){super(e)}add(e,t,r,i,n){const a=this.array,o=O.Z.i1616to32(2*e+r,2*t+i);a.push(o),n&&a.push(...n)}}class ue{constructor(e,t,r){this.layerExtent=4096,this._features=[],this.layer=e,this.zoom=t,this._spriteInfo=r,this._filter=e.getFeatureFilter()}pushFeature(e){this._filter&&!this._filter.filter(e,this.zoom)||this._features.push(e)}hasFeatures(){return this._features.length>0}getResources(e,t,r){}}class et extends ue{constructor(e,t,r,i,n){super(e,t,r),this.type=Y.al.CIRCLE,this._circleVertexBuffer=i,this._circleIndexBuffer=n}get circleIndexStart(){return this._circleIndexStart}get circleIndexCount(){return this._circleIndexCount}processFeatures(e){const t=this._circleVertexBuffer,r=this._circleIndexBuffer;this._circleIndexStart=3*r.index,this._circleIndexCount=0;const i=this.layer,n=this.zoom;e&&e.setExtent(this.layerExtent);for(const a of this._features){const o=a.getGeometry(e);if(!o)continue;const l=i.circleMaterial.encodeAttributes(a,n,i);for(const u of o)if(u)for(const f of u){const d=t.index;t.add(f.x,f.y,0,0,l),t.add(f.x,f.y,0,1,l),t.add(f.x,f.y,1,0,l),t.add(f.x,f.y,1,1,l),r.add(d+0,d+1,d+2),r.add(d+1,d+2,d+3),this._circleIndexCount+=6}}}serialize(){let e=6;e+=this.layerUIDs.length,e+=this._circleVertexBuffer.array.length,e+=this._circleIndexBuffer.array.length;const t=new Uint32Array(e),r=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let n=0;n<this.layerUIDs.length;n++)t[i++]=this.layerUIDs[n];t[i++]=this._circleIndexStart,t[i++]=this._circleIndexCount,t[i++]=this._circleVertexBuffer.array.length;for(let n=0;n<this._circleVertexBuffer.array.length;n++)r[i++]=this._circleVertexBuffer.array[n];t[i++]=this._circleIndexBuffer.array.length;for(let n=0;n<this._circleIndexBuffer.array.length;n++)t[i++]=this._circleIndexBuffer.array[n];return t.buffer}}var Se=C(35575),Ce=C(11915);class Me extends ue{constructor(e,t,r,i,n,a,o){super(e,t,r),this.type=Y.al.FILL,this._patternMap=new Map,this._fillVertexBuffer=i,this._fillIndexBuffer=n,this._outlineVertexBuffer=a,this._outlineIndexBuffer=o}get fillIndexStart(){return this._fillIndexStart}get fillIndexCount(){return this._fillIndexCount}get outlineIndexStart(){return this._outlineIndexStart}get outlineIndexCount(){return this._outlineIndexCount}getResources(e,t,r){const n=this.zoom,a=this.layer.getPaintProperty("fill-pattern");if(a)if(a.isDataDriven)for(const o of this._features)t(a.getValue(n,o),!0);else t(a.getValue(n),!0)}processFeatures(e){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const t=this.layer,r=this.zoom,{fillMaterial:i,outlineMaterial:n,hasDataDrivenFill:a,hasDataDrivenOutline:o}=t;e&&e.setExtent(this.layerExtent);const l=t.getPaintProperty("fill-pattern"),u=l?.isDataDriven;let f=!l&&t.getPaintValue("fill-antialias",r);if(t.outlineUsesFillColor){if(f&&!t.hasDataDrivenOpacity){const y=t.getPaintValue("fill-opacity",r),g=t.getPaintValue("fill-opacity",r+1);y<1&&g<1&&(f=!1)}if(f&&!t.hasDataDrivenColor){const y=t.getPaintValue("fill-color",r),g=t.getPaintValue("fill-color",r+1);y[3]<1&&g[3]<1&&(f=!1)}}const d=this._features,h=e?.validateTessellation;if(u){const y=[];for(const g of d){const m=l.getValue(r,g),T=this._spriteInfo[m];if(!T||!T.rect)continue;const x=i.encodeAttributes(g,r,t,T),_=f&&o?n.encodeAttributes(g,r,t):[],p=g.getGeometry(e);y.push({ddFillAttributes:x,ddOutlineAttributes:_,page:T.page,geometry:p}),y.sort((M,B)=>M.page-B.page);for(const{ddFillAttributes:M,ddOutlineAttributes:B,page:I,geometry:P}of y)this._processFeature(P,f,t.outlineUsesFillColor,M,B,h,I)}}else for(const y of d){const g=a?i.encodeAttributes(y,r,t):null,m=f&&o?n.encodeAttributes(y,r,t):null,T=y.getGeometry(e);this._processFeature(T,f,t.outlineUsesFillColor,g,m,h)}}serialize(){let e=10;e+=this.layerUIDs.length,e+=this._fillVertexBuffer.array.length,e+=this._fillIndexBuffer.array.length,e+=this._outlineVertexBuffer.array.length,e+=this._outlineIndexBuffer.array.length,e+=3*this._patternMap.size+1;const t=new Uint32Array(e),r=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let o=0;o<this.layerUIDs.length;o++)t[i++]=this.layerUIDs[o];t[i++]=this._fillIndexStart,t[i++]=this._fillIndexCount,t[i++]=this._outlineIndexStart,t[i++]=this._outlineIndexCount;const n=this._patternMap,a=n.size;if(t[i++]=a,a>0)for(const[o,[l,u]]of n)t[i++]=o,t[i++]=l,t[i++]=u;t[i++]=this._fillVertexBuffer.array.length;for(let o=0;o<this._fillVertexBuffer.array.length;o++)r[i++]=this._fillVertexBuffer.array[o];t[i++]=this._fillIndexBuffer.array.length;for(let o=0;o<this._fillIndexBuffer.array.length;o++)t[i++]=this._fillIndexBuffer.array[o];t[i++]=this._outlineVertexBuffer.array.length;for(let o=0;o<this._outlineVertexBuffer.array.length;o++)r[i++]=this._outlineVertexBuffer.array[o];t[i++]=this._outlineIndexBuffer.array.length;for(let o=0;o<this._outlineIndexBuffer.array.length;o++)t[i++]=this._outlineIndexBuffer.array[o];return t.buffer}_processFeature(e,t,r,i,n,a,o){if(!e)return;const l=e.length;if(t&&(!r||!n||0===n.length))for(let h=0;h<l;h++)this._processOutline(e[h],n);let d;for(let h=0;h<l;h++){const y=Me._area(e[h]);y>32?(void 0!==d&&this._processFill(e,d,i,a,o),d=[h]):y<-32&&void 0!==d&&d.push(h)}void 0!==d&&this._processFill(e,d,i,a,o)}_processOutline(e,t){const r=this._outlineVertexBuffer,i=this._outlineIndexBuffer,n=i.index;let a,o,l;const u=new E.E(0,0),f=new E.E(0,0),d=new E.E(0,0);let h=-1,y=-1,g=-1,m=-1,T=-1,x=!1,p=e.length;if(p<2)return;const M=e[0];let B=e[p-1];for(;p&&B.isEqual(M);)--p,B=e[p-1];if(!(p-0<2)){for(let I=0;I<p;++I){0===I?(a=e[p-1],o=e[0],l=e[1],u.assignSub(o,a),u.normalize(),u.rightPerpendicular()):(a=o,o=l,l=I!==p-1?e[I+1]:e[0],u.assign(f));const P=this._isClipEdge(a,o);-1===m&&(x=P),f.assignSub(l,o),f.normalize(),f.rightPerpendicular();const L=u.x*f.y-u.y*f.x;d.assignAdd(u,f),d.normalize();const b=-d.x*-u.x+-d.y*-u.y;let D=Math.abs(0!==b?1/b:1);D>8&&(D=8),L>=0?(g=r.add(o.x,o.y,u.x,u.y,0,1,t),-1===m&&(m=g),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),y=r.add(o.x,o.y,D*-d.x,D*-d.y,0,-1,t),-1===T&&(T=y),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),h=y,y=g,g=r.add(o.x,o.y,d.x,d.y,0,1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),y=r.add(o.x,o.y,f.x,f.y,0,1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g)):(g=r.add(o.x,o.y,D*d.x,D*d.y,0,1,t),-1===m&&(m=g),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),y=r.add(o.x,o.y,-u.x,-u.y,0,-1,t),-1===T&&(T=y),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),h=y,y=g,g=r.add(o.x,o.y,-d.x,-d.y,0,-1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g),h=r.add(o.x,o.y,-f.x,-f.y,0,-1,t),h>=0&&y>=0&&g>=0&&!P&&i.add(h,y,g))}h>=0&&y>=0&&m>=0&&!x&&i.add(h,y,m),h>=0&&m>=0&&T>=0&&!x&&i.add(h,T,m),this._outlineIndexCount+=3*(i.index-n)}}_processFill(e,t,r,i,n){let a;t.length>1&&(a=[]);let o=0;for(const d of t)0!==o&&a.push(o),o+=e[d].length;const l=2*o,u=Se.Z.acquire();for(const d of t){const h=e[d],y=h.length;for(let g=0;g<y;++g)u.push(h[g].x,h[g].y)}const f=(0,Ce.e)(u,a,2);if(Ce.e.deviation(u,a,2,f)>0){const d=t.map(g=>e[g].length),{buffer:h,vertexCount:y}=(0,ke.b)(u,d);if(y>0){const g=this._fillVertexBuffer.index;for(let m=0;m<y;m++)this._fillVertexBuffer.add(h[2*m],h[2*m+1],r);for(let m=0;m<y;m+=3){const T=g+m;this._fillIndexBuffer.add(T,T+1,T+2)}if(void 0!==n){const m=this._patternMap,T=m.get(n);T?T[1]+=y:m.set(n,[this._fillIndexStart+this._fillIndexCount,y])}this._fillIndexCount+=y}}else{const d=f.length;if(d>0){const h=this._fillVertexBuffer.index;let y=0;for(;y<l;)this._fillVertexBuffer.add(u[y++],u[y++],r);let g=0;for(;g<d;)this._fillIndexBuffer.add(h+f[g++],h+f[g++],h+f[g++]);if(void 0!==n){const m=this._patternMap,T=m.get(n);T?T[1]+=d:m.set(n,[this._fillIndexStart+this._fillIndexCount,d])}this._fillIndexCount+=d}}Se.Z.release(u)}_isClipEdge(e,t){return e.x===t.x?e.x<=-64||e.x>=4160:e.y===t.y&&(e.y<=-64||e.y>=4160)}static _area(e){let t=0;const r=e.length-1;for(let i=0;i<r;i++)t+=(e[i].x-e[i+1].x)*(e[i].y+e[i+1].y);return t+=(e[r].x-e[0].x)*(e[r].y+e[0].y),.5*t}}var tt=C(46519);class it extends ue{constructor(e,t,r,i,n){super(e,t,r),this.type=Y.al.LINE,this._tessellationOptions={pixelCoordRatio:8,halfWidth:0,offset:0},this._patternMap=new Map,this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_ddValues:null},this.tessellationProperties._lineVertexBuffer=i,this.tessellationProperties._lineIndexBuffer=n,this._lineTessellator=new tt.z(rt(this.tessellationProperties),nt(this.tessellationProperties),e.canUseThinTessellation)}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}getResources(e,t,r){const i=this.layer,n=this.zoom,a=i.hasDataDrivenLine,o=i.getPaintProperty("line-pattern"),l=i.getPaintProperty("line-dasharray"),u=i.getLayoutProperty("line-cap");if(!o&&!l)return;const f=u?.getValue(n)||0,d=u?.isDataDriven;if(a){const h=o?.isDataDriven,y=l?.isDataDriven;if(!h&&!y)return;for(const g of this._features)t(h?o.getValue(n,g):this._getDashArrayKey(g,n,i,l,d,u,f))}else if(o)t(o.getValue(n));else if(l){const h=l.getValue(n);t(i.getDashKey(h,f))}}processFeatures(e){this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const t=this.layer,r=this.zoom,i=this._features,n=this._tessellationOptions,{hasDataDrivenLine:a,lineMaterial:o}=t;e&&e.setExtent(this.layerExtent);const l=t.getPaintProperty("line-pattern"),u=t.getPaintProperty("line-dasharray"),f=l?.isDataDriven,d=u?.isDataDriven;let h;h=t.getLayoutProperty("line-cap");const y=h?.isDataDriven?h:null,g=y?null:t.getLayoutValue("line-cap",r),m=g||0,T=!!y;h=t.getLayoutProperty("line-join");const x=h?.isDataDriven?h:null,_=x?null:t.getLayoutValue("line-join",r);h=t.getLayoutProperty("line-miter-limit");const p=h?.isDataDriven?h:null,M=p?null:t.getLayoutValue("line-miter-limit",r);h=t.getLayoutProperty("line-round-limit");const B=h?.isDataDriven?h:null,I=B?null:t.getLayoutValue("line-round-limit",r);h=t.getPaintProperty("line-width");const P=h?.isDataDriven?h:null,L=P?null:t.getPaintValue("line-width",r);h=t.getPaintProperty("line-offset");const b=h?.isDataDriven?h:null,D=b?null:t.getPaintValue("line-offset",r);if(f||d){const A=[];for(const w of i){const S=f?l.getValue(r,w):this._getDashArrayKey(w,r,t,u,T,y,m),k=this._spriteInfo[S];if(!k||!k.rect)continue;const R=o.encodeAttributes(w,r,t,k),U=w.getGeometry(e);A.push({ddAttributes:R,page:k.page,cap:y?y.getValue(r,w):g,join:x?x.getValue(r,w):_,miterLimit:p?p.getValue(r,w):M,roundLimit:B?B.getValue(r,w):I,halfWidth:.5*(P?P.getValue(r,w):L),offset:b?b.getValue(r,w):D,geometry:U})}A.sort((w,S)=>w.page-S.page),n.textured=!0;for(const{ddAttributes:w,page:S,cap:k,join:R,miterLimit:U,roundLimit:ee,halfWidth:H,offset:X,geometry:te}of A)n.capType=k,n.joinType=R,n.miterLimit=U,n.roundLimit=ee,n.halfWidth=H,n.offset=X,this._processFeature(te,w,S)}else{n.textured=!(!l&&!u),n.capType=g,n.joinType=_,n.miterLimit=M,n.roundLimit=I,n.halfWidth=.5*L,n.offset=D;for(const A of i){const w=a?o.encodeAttributes(A,r,t):null;y&&(n.capType=y.getValue(r,A)),x&&(n.joinType=x.getValue(r,A)),p&&(n.miterLimit=p.getValue(r,A)),B&&(n.roundLimit=B.getValue(r,A)),P&&(n.halfWidth=.5*P.getValue(r,A)),b&&(n.offset=b.getValue(r,A));const S=A.getGeometry(e);this._processFeature(S,w)}}}serialize(){let e=6;e+=this.layerUIDs.length,e+=this.tessellationProperties._lineVertexBuffer.array.length,e+=this.tessellationProperties._lineIndexBuffer.array.length,e+=3*this._patternMap.size+1;const t=new Uint32Array(e),r=new Int32Array(t.buffer);let i=0;t[i++]=this.type,t[i++]=this.layerUIDs.length;for(let o=0;o<this.layerUIDs.length;o++)t[i++]=this.layerUIDs[o];t[i++]=this._lineIndexStart,t[i++]=this._lineIndexCount;const n=this._patternMap,a=n.size;if(t[i++]=a,a>0)for(const[o,[l,u]]of n)t[i++]=o,t[i++]=l,t[i++]=u;t[i++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let o=0;o<this.tessellationProperties._lineVertexBuffer.array.length;o++)r[i++]=this.tessellationProperties._lineVertexBuffer.array[o];t[i++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let o=0;o<this.tessellationProperties._lineIndexBuffer.array.length;o++)t[i++]=this.tessellationProperties._lineIndexBuffer.array[o];return t.buffer}_processFeature(e,t,r){if(!e)return;const i=e.length;for(let n=0;n<i;n++)this._processGeometry(e[n],t,r)}_processGeometry(e,t,r){if(e.length<2)return;let n,a,o=e[0],l=1;for(;l<e.length;)n=e[l].x-o.x,a=e[l].y-o.y,n*n+a*a<1e-6?e.splice(l,1):(o=e[l],++l);if(e.length<2)return;const u=this.tessellationProperties._lineIndexBuffer,f=3*u.index;this._tessellationOptions.initialDistance=0,this._tessellationOptions.wrapDistance=65535,this.tessellationProperties._ddValues=t,this._lineTessellator.tessellate(e,this._tessellationOptions);const d=3*u.index-f;if(void 0!==r){const h=this._patternMap,y=h.get(r);y?y[1]+=d:h.set(r,[f+this._lineIndexCount,d])}this._lineIndexCount+=d}_getDashArrayKey(e,t,r,i,n,a,o){const l=n?a.getValue(t,e):o,u=i.getValue(t,e);return r.getDashKey(u,l)}}const rt=c=>(e,t,r,i,n,a,o,l,u,f,d)=>(c._lineVertexBuffer.add(e,t,o,l,r,i,n,a,u,f,d,c._ddValues),c._lineVertexBuffer.index-1),nt=c=>(e,t,r)=>{c._lineIndexBuffer.add(e,t,r)};var at=C(6879),Fe=C(77275),Oe=C(13295);function ot(c,e){return c.iconMosaicItem&&e.iconMosaicItem?c.iconMosaicItem.page===e.iconMosaicItem.page?0:c.iconMosaicItem.page-e.iconMosaicItem.page:c.iconMosaicItem&&!e.iconMosaicItem?1:!c.iconMosaicItem&&e.iconMosaicItem?-1:0}class G extends ue{constructor(e,t,r,i,n,a,o,l){super(e,t,l.getSpriteItems()),this.type=Y.al.SYMBOL,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,this._iconVertexBuffer=r,this._iconIndexBuffer=i,this._textVertexBuffer=n,this._textIndexBuffer=a,this._placementEngine=o,this._workerTileHandler=l}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}getResources(e,t,r){const i=this.layer,n=this.zoom;e&&e.setExtent(this.layerExtent);const a=i.getLayoutProperty("icon-image"),o=i.getLayoutProperty("text-field");let l=i.getLayoutProperty("text-transform"),u=i.getLayoutProperty("text-font");const f=[];let d,h,y,g;a&&!a.isDataDriven&&(d=a.getValue(n)),o&&!o.isDataDriven&&(h=o.getValue(n)),l&&l.isDataDriven||(y=i.getLayoutValue("text-transform",n),l=null),u&&u.isDataDriven||(g=i.getLayoutValue("text-font",n),u=null);for(const m of this._features){const T=m.getGeometry(e);if(!T||0===T.length)continue;let x,_;a&&(x=a.isDataDriven?a.getValue(n,m):this._replaceKeys(d,m.values),x&&t(x));let p=!1;if(o&&(_=o.isDataDriven?o.getValue(n,m):this._replaceKeys(h,m.values),_)){switch(_=_.replace(/\\n/g,"\n"),l&&(y=l.getValue(n,m)),y){case V._5.LOWERCASE:_=_.toLowerCase();break;case V._5.UPPERCASE:_=_.toUpperCase()}if(G._bidiEngine.hasBidiChar(_)){let P;P="rtl"===G._bidiEngine.checkContextual(_)?"IDNNN":"ICNNN",_=G._bidiEngine.bidiTransform(_,P,"VLYSN"),p=!0}const I=_.length;if(I>0){u&&(g=u.getValue(n,m));for(const P of g){let L=r[P];L||(L=r[P]=new Set);for(let b=0;b<I;b++){const D=_.charCodeAt(b);L.add(D)}}}}if(!x&&!_)continue;const M=i.getLayoutValue("symbol-sort-key",n,m),B={feature:m,sprite:x,label:_,rtl:p,geometry:T,hash:(_?(0,Fe.hP)(_):0)^(x?(0,Fe.hP)(x):0),priority:M,textFont:g};f.push(B)}this._symbolFeatures=f}processFeatures(e){e&&e.setExtent(this.layerExtent);const t=this.layer,r=this.zoom,i=t.getLayoutValue("symbol-placement",r),n=i!==V.R.POINT,a=8*t.getLayoutValue("symbol-spacing",r),o=t.getLayoutProperty("icon-image"),l=t.getLayoutProperty("text-field"),u=o?new Oe._L(t,r,n):null,f=l?new Oe.nj(t,r,n):null,d=this._workerTileHandler;let h;o&&(h=d.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const y=[];let g=1;f&&f.size&&(g=f.size/Z);const m=f?f.maxAngle*v.DT:0,T=f?8*f.size:0;for(const x of this._symbolFeatures){let _,p;u&&h&&x.sprite&&(_=h[x.sprite],_&&_.sdf&&(this._isIconSDF=!0)),_&&u.update(r,x.feature);let M=0;const B=x.label;if(B){f.update(r,x.feature);const I=n?f.keepUpright:f.writingMode&&f.writingMode.includes(V.r1.VERTICAL);let P=.5;switch(f.anchor){case V.nR.TOP_LEFT:case V.nR.LEFT:case V.nR.BOTTOM_LEFT:P=0;break;case V.nR.TOP_RIGHT:case V.nR.RIGHT:case V.nR.BOTTOM_RIGHT:P=1}let L=.5;switch(f.anchor){case V.nR.TOP_LEFT:case V.nR.TOP:case V.nR.TOP_RIGHT:L=0;break;case V.nR.BOTTOM_LEFT:case V.nR.BOTTOM:case V.nR.BOTTOM_RIGHT:L=1}let b=.5;switch(f.justify){case V.vL.AUTO:b=P;break;case V.vL.LEFT:b=0;break;case V.vL.RIGHT:b=1}const D=f.letterSpacing*Z,A=n?0:f.maxWidth*Z,w=f.lineHeight*Z,S=x.textFont.map(k=>d.getGlyphItems(k));if(p=new De(S,A,w,D,P,L,b).getShaping(B,x.rtl,I),p&&p.length>0){let k=1e30,R=-1e30;for(const U of p)k=Math.min(k,U.x),R=Math.max(R,U.x);M=(R-k+48)*g*8}}for(let I of x.geometry){const P=[];if(i===V.R.LINE){if(p&&p.length>0&&f&&f.size){const L=8*f.size*(2+Math.min(2,4*Math.abs(f.offset[1])));I=G._smoothVertices(I,L)}G._pushAnchors(P,I,a,M)}else i===V.R.LINE_CENTER?G._pushCenterAnchor(P,I):x.feature.type===E.V.Polygon?G._pushCentroid(P,I):P.push(new he(I[0].x,I[0].y));for(const L of P){if(L.x<0||L.x>4096||L.y<0||L.y>4096||n&&M>0&&f.rotationAlignment===V.aF.MAP&&!G._honorsTextMaxAngle(I,L,M,m,T))continue;const b={shaping:p,line:I,iconMosaicItem:_,anchor:L,symbolFeature:x,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};y.push(b),this._processFeature(b,u,f)}}}y.sort(ot),this._addPlacedGlyphs(),this._symbolInstances=y}serialize(){let e=11;e+=this.layerUIDs.length,e+=3*this.markerPageMap.size,e+=3*this.glyphsPageMap.size,e+=G._symbolsSerializationLength(this._symbolInstances),e+=this._iconVertexBuffer.array.length,e+=this._iconIndexBuffer.array.length,e+=this._textVertexBuffer.array.length,e+=this._textIndexBuffer.array.length;const t=new Uint32Array(e),r=new Int32Array(t.buffer),i=new Float32Array(t.buffer);let n=0;t[n++]=this.type,t[n++]=this.layerUIDs.length;for(let a=0;a<this.layerUIDs.length;a++)t[n++]=this.layerUIDs[a];t[n++]=this._isIconSDF?1:0,t[n++]=this.markerPageMap.size;for(const[a,[o,l]]of this.markerPageMap)t[n++]=a,t[n++]=o,t[n++]=l;t[n++]=this.glyphsPageMap.size;for(const[a,[o,l]]of this.glyphsPageMap)t[n++]=a,t[n++]=o,t[n++]=l;t[n++]=this._iconVertexBuffer.index/4,t[n++]=this._textVertexBuffer.index/4,n=G.serializeSymbols(t,r,i,n,this._symbolInstances),t[n++]=this._iconVertexBuffer.array.length;for(let a=0;a<this._iconVertexBuffer.array.length;a++)r[n++]=this._iconVertexBuffer.array[a];t[n++]=this._iconIndexBuffer.array.length;for(let a=0;a<this._iconIndexBuffer.array.length;a++)t[n++]=this._iconIndexBuffer.array[a];t[n++]=this._textVertexBuffer.array.length;for(let a=0;a<this._textVertexBuffer.array.length;a++)r[n++]=this._textVertexBuffer.array[a];t[n++]=this._textIndexBuffer.array.length;for(let a=0;a<this._textIndexBuffer.array.length;a++)t[n++]=this._textIndexBuffer.array[a];return t.buffer}static _symbolsSerializationLength(e){let t=0;t+=1;for(const r of e||[]){t+=4,t+=1;for(const i of r.textColliders)t+=10;for(const i of r.iconColliders)t+=10;t+=1,t+=2*r.textVertexRanges.length,t+=1,t+=2*r.iconVertexRanges.length}return t}static serializeSymbols(e,t,r,i,n){t[i++]=(n=n||[]).length;for(const a of n){t[i++]=a.anchor.x,t[i++]=a.anchor.y,t[i++]=a.symbolFeature.hash,t[i++]=a.symbolFeature.priority,t[i++]=a.textColliders.length+a.iconColliders.length;for(const o of a.textColliders)t[i++]=o.xTile,t[i++]=o.yTile,t[i++]=o.dxPixels,t[i++]=o.dyPixels,t[i++]=o.hard?1:0,t[i++]=o.partIndex,r[i++]=o.minLod,r[i++]=o.maxLod,t[i++]=o.width,t[i++]=o.height;for(const o of a.iconColliders)t[i++]=o.xTile,t[i++]=o.yTile,t[i++]=o.dxPixels,t[i++]=o.dyPixels,t[i++]=o.hard?1:0,t[i++]=o.partIndex,r[i++]=o.minLod,r[i++]=o.maxLod,t[i++]=o.width,t[i++]=o.height;t[i++]=a.textVertexRanges.length;for(const[o,l]of a.textVertexRanges)t[i++]=o,t[i++]=l;t[i++]=a.iconVertexRanges.length;for(const[o,l]of a.iconVertexRanges)t[i++]=o,t[i++]=l}return i}_replaceKeys(e,t){return e.replace(/{([^{}]+)}/g,(r,i)=>i in t?t[i]:"")}_processFeature(e,t,r){const{line:i,iconMosaicItem:n,shaping:a,anchor:o}=e,l=this.zoom,u=this.layer,f=!!n;let d=!0;f&&(d=t.optional||!n);const h=a&&a.length>0;let y,g,m=!0;if(h&&(m=r.optional),f&&(y=this._placementEngine.getIconPlacement(o,n,t)),(y||d)&&(h&&(g=this._placementEngine.getTextPlacement(o,a,i,r)),g||m)){if(y&&g||(m||d?m||g?d||y||(g=null):y=null:(y=null,g=null)),g){const T=u.hasDataDrivenText?u.textMaterial.encodeAttributes(e.symbolFeature.feature,l,u):null;if(this._storePlacedGlyphs(e,g.shapes,l,r.rotationAlignment,T),g.textColliders){e.textColliders=g.textColliders;for(const x of g.textColliders){x.minLod=Math.max(l+(0,v.k3)(x.minLod),0),x.maxLod=Math.min(l+(0,v.k3)(x.maxLod),25);const _=x.angle;if(_){const p=Math.cos(_),M=Math.sin(_),B=x.dxPixels*p-x.dyPixels*M,I=x.dxPixels*M+x.dyPixels*p,P=(x.dxPixels+x.width)*p-x.dyPixels*M,L=(x.dxPixels+x.width)*M+x.dyPixels*p,b=x.dxPixels*p-(x.dyPixels+x.height)*M,D=x.dxPixels*M+(x.dyPixels+x.height)*p,A=(x.dxPixels+x.width)*p-(x.dyPixels+x.height)*M,w=(x.dxPixels+x.width)*M+(x.dyPixels+x.height)*p,S=Math.min(B,P,b,A),k=Math.max(B,P,b,A),R=Math.min(I,L,D,w),U=Math.max(I,L,D,w);x.dxPixels=S,x.dyPixels=R,x.width=k-S,x.height=U-R}}}}if(y){const T=u.hasDataDrivenIcon?u.iconMaterial.encodeAttributes(e.symbolFeature.feature,l,u):null;if(this._addPlacedIcons(e,y.shapes,l,n.page,t.rotationAlignment===V.aF.VIEWPORT,T),y.iconColliders){e.iconColliders=y.iconColliders;for(const x of y.iconColliders){x.minLod=Math.max(l+(0,v.k3)(x.minLod),0),x.maxLod=Math.min(l+(0,v.k3)(x.maxLod),25);const _=x.angle;if(_){const p=Math.cos(_),M=Math.sin(_),B=x.dxPixels*p-x.dyPixels*M,I=x.dxPixels*M+x.dyPixels*p,P=(x.dxPixels+x.width)*p-x.dyPixels*M,L=(x.dxPixels+x.width)*M+x.dyPixels*p,b=x.dxPixels*p-(x.dyPixels+x.height)*M,D=x.dxPixels*M+(x.dyPixels+x.height)*p,A=(x.dxPixels+x.width)*p-(x.dyPixels+x.height)*M,w=(x.dxPixels+x.width)*M+(x.dyPixels+x.height)*p,S=Math.min(B,P,b,A),k=Math.max(B,P,b,A),R=Math.min(I,L,D,w),U=Math.max(I,L,D,w);x.dxPixels=S,x.dyPixels=R,x.width=k-S,x.height=U-R}}}}}}_addPlacedIcons(e,t,r,i,n,a){const o=Math.max(r-1,0),l=this._iconVertexBuffer,u=this._iconIndexBuffer,f=this._markerMap;for(const d of t){const h=n?0:Math.max(r+(0,v.k3)(d.minzoom),o),y=n?25:Math.min(r+(0,v.k3)(d.maxzoom),25);if(y<=h)continue;const g=d.tl,m=d.tr,T=d.bl,x=d.br,_=d.mosaicRect,p=d.labelAngle,M=d.minAngle,B=d.maxAngle,I=d.anchor,P=l.index,L=_.x,b=_.y,D=L+_.width,A=b+_.height,w=l.index;l.add(I.x,I.y,g.x,g.y,L,b,p,M,B,h,y,a),l.add(I.x,I.y,m.x,m.y,D,b,p,M,B,h,y,a),l.add(I.x,I.y,T.x,T.y,L,A,p,M,B,h,y,a),l.add(I.x,I.y,x.x,x.y,D,A,p,M,B,h,y,a),e.iconVertexRanges.length>0&&e.iconVertexRanges[0][0]+e.iconVertexRanges[0][1]===w?e.iconVertexRanges[0][1]+=4:e.iconVertexRanges.push([w,4]),u.add(P+0,P+1,P+2),u.add(P+1,P+2,P+3),f.has(i)?f.get(i)[1]+=6:f.set(i,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const e=this._textVertexBuffer,t=this._textIndexBuffer,r=this._glyphMap;for(const[i,n]of this._glyphBufferDataStorage)for(const a of n){const o=e.index,l=a.symbolInstance,u=a.ddAttributes,f=e.index;e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.tl[0],a.tl[1],a.xmin,a.ymin,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,u),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.tr[0],a.tr[1],a.xmax,a.ymin,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,u),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.bl[0],a.bl[1],a.xmin,a.ymax,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,u),e.add(a.glyphAnchor[0],a.glyphAnchor[1],a.br[0],a.br[1],a.xmax,a.ymax,a.labelAngle,a.minAngle,a.maxAngle,a.minLod,a.maxLod,u),l.textVertexRanges.length>0&&l.textVertexRanges[0][0]+l.textVertexRanges[0][1]===f?l.textVertexRanges[0][1]+=4:l.textVertexRanges.push([f,4]),t.add(o+0,o+1,o+2),t.add(o+1,o+2,o+3),r.has(i)?r.get(i)[1]+=6:r.set(i,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(e,t,r,i,n){const a=Math.max(r-1,0),o=i===V.aF.VIEWPORT;let l,u,f,d,h,y,g,m,T,x,_;for(const p of t)l=o?0:Math.max(r+(0,v.k3)(p.minzoom),a),u=o?25:Math.min(r+(0,v.k3)(p.maxzoom),25),!(u<=l)&&(f=p.tl,d=p.tr,h=p.bl,y=p.br,g=p.labelAngle,m=p.minAngle,T=p.maxAngle,x=p.anchor,_=p.mosaicRect,this._glyphBufferDataStorage.has(p.page)||this._glyphBufferDataStorage.set(p.page,[]),this._glyphBufferDataStorage.get(p.page).push({glyphAnchor:[x.x,x.y],tl:[f.x,f.y],tr:[d.x,d.y],bl:[h.x,h.y],br:[y.x,y.y],xmin:_.x,ymin:_.y,xmax:_.x+_.width,ymax:_.y+_.height,labelAngle:g,minAngle:m,maxAngle:T,minLod:l,maxLod:u,placementLod:a,symbolInstance:e,ddAttributes:n}))}static _pushAnchors(e,t,r,i){r+=i;let n=0;const a=t.length-1;for(let h=0;h<a;h++)n+=E.E.distance(t[h],t[h+1]);let o=i||r;if(o*=.5,n<=o)return;const l=o/n;let u=0,f=-(r=n/Math.max(Math.round(n/r),1))/2;const d=t.length-1;for(let h=0;h<d;h++){const y=t[h],g=t[h+1],m=g.x-y.x,T=g.y-y.y,x=Math.sqrt(m*m+T*T);let _;for(;f+r<u+x;){f+=r;const p=(f-u)/x,M=(0,v.sX)(y.x,g.x,p),B=(0,v.sX)(y.y,g.y,p);void 0===_&&(_=Math.atan2(T,m)),e.push(new he(M,B,_,h,l))}u+=x}}static _pushCenterAnchor(e,t){let r=0;const i=t.length-1;for(let l=0;l<i;l++)r+=E.E.distance(t[l],t[l+1]);const n=r/2;let a=0;const o=t.length-1;for(let l=0;l<o;l++){const u=t[l],f=t[l+1],d=f.x-u.x,h=f.y-u.y,y=Math.sqrt(d*d+h*h);if(n<a+y){const g=(n-a)/y,m=(0,v.sX)(u.x,f.x,g),T=(0,v.sX)(u.y,f.y,g),x=Math.atan2(h,d);return void e.push(new he(m,T,x,l,0))}a+=y}}static _deviation(e,t,r){return Math.atan2((t.x-e.x)*(r.y-t.y)-(t.y-e.y)*(r.x-t.x),(t.x-e.x)*(r.x-t.x)+(t.y-e.y)*(r.y-t.y))}static _honorsTextMaxAngle(e,t,r,i,n){let a=0;const o=r/2;let l=new E.E(t.x,t.y),u=t.segment+1;for(;a>-o;){if(--u,u<0)return!1;a-=E.E.distance(e[u],l),l=e[u]}a+=E.E.distance(e[u],e[u+1]);const f=[];let d=0;const h=e.length;for(;a<o;){const y=e[u];let g,m=u;do{if(++m,m===h)return!1;g=e[m]}while(g.isEqual(y));let T,x=m;do{if(++x,x===h)return!1;T=e[x]}while(T.isEqual(g));const _=this._deviation(y,g,T);for(f.push({deviation:_,distToAnchor:a}),d+=_;a-f[0].distToAnchor>n;)d-=f.shift().deviation;if(Math.abs(d)>i)return!1;a+=E.E.distance(g,T),u=m}return!0}static _smoothVertices(e,t){if(t<=0)return e;let r=e.length;if(r<3)return e;const i=[];let n=0,a=0;i.push(0);for(let m=1;m<r;m++){const T=E.E.distance(e[m],e[m-1]);T>0&&(n+=T,i.push(n),a++,a!==m&&(e[a]=e[m]))}if(r=a+1,r<3)return e;t=Math.min(t,.2*n);const o=e[0].x,l=e[0].y,u=e[r-1].x,f=e[r-1].y,d=E.E.sub(e[0],e[1]);d.normalize(),e[0].x+=t*d.x,e[0].y+=t*d.y,d.assignSub(e[r-1],e[r-2]),d.normalize(),e[r-1].x+=t*d.x,e[r-1].y+=t*d.y,i[0]-=t,i[r-1]+=t;const h=[];h.push(new E.E(o,l));const y=1e-6,g=.5*t;for(let m=1;m<r-1;m++){let T=0,x=0,_=0;for(let p=m-1;p>=0;p--){const M=g+i[p+1]-i[m];if(M<0)break;const B=i[p+1]-i[p],I=i[m]-i[p]<g?1:M/B;if(I<y)break;const P=I*I,L=I*M-.5*P*B,b=I*B/t,D=e[p+1],A=e[p].x-D.x,w=e[p].y-D.y;T+=b/L*(D.x*I*M+.5*P*(M*A-B*D.x)-P*I*B*A/3),x+=b/L*(D.y*I*M+.5*P*(M*w-B*D.y)-P*I*B*w/3),_+=b}for(let p=m+1;p<r;p++){const M=g-i[p-1]+i[m];if(M<0)break;const B=i[p]-i[p-1],I=i[p]-i[m]<g?1:M/B;if(I<y)break;const P=I*I,L=I*M-.5*P*B,b=I*B/t,D=e[p-1],A=e[p].x-D.x,w=e[p].y-D.y;T+=b/L*(D.x*I*M+.5*P*(M*A-B*D.x)-P*I*B*A/3),x+=b/L*(D.y*I*M+.5*P*(M*w-B*D.y)-P*I*B*w/3),_+=b}h.push(new E.E(T/_,x/_))}return h.push(new E.E(u,f)),e[0].x=o,e[0].y=l,e[r-1].x=u,e[r-1].y=f,h}static _pushCentroid(e,t){const o=t.length-1;let l=0,u=0,f=0,d=t[0].x,h=t[0].y;d>4096&&(d=4096),d<0&&(d=0),h>4096&&(h=4096),h<0&&(h=0);for(let y=1;y<o;y++){let g=t[y].x,m=t[y].y,T=t[y+1].x,x=t[y+1].y;g>4096&&(g=4096),g<0&&(g=0),m>4096&&(m=4096),m<0&&(m=0),T>4096&&(T=4096),T<0&&(T=0),x>4096&&(x=4096),x<0&&(x=0);const _=(g-d)*(x-h)-(T-d)*(m-h);l+=_*(d+g+T),u+=_*(h+m+x),f+=_}l/=3*f,u/=3*f,isNaN(l)||isNaN(u)||e.push(new he(l,u))}}G._bidiEngine=new at.Z;var J,ze=C(47018);!function(c){c[c.INITIALIZED=0]="INITIALIZED",c[c.NO_DATA=1]="NO_DATA",c[c.READY=2]="READY",c[c.MODIFIED=3]="MODIFIED",c[c.INVALID=4]="INVALID"}(J||(J={}));class ut{constructor(e,t,r,i,n){if(this._pbfTiles={},this._tileClippers={},this._client=r,this._tile=t,n){this._styleLayerUIDs=new Set;for(const f of n)this._styleLayerUIDs.add(f)}this._styleRepository=i,this._layers=this._styleRepository.layers;const[a,o,l]=t.tileKey.split("/").map(parseFloat);this._level=a;const u=8+Math.max(5*(this._level-14),0);for(const f of Object.keys(e)){const d=e[f];if(this._pbfTiles[f]=new Ye.Z(new Uint8Array(d.protobuff),new DataView(d.protobuff)),d.refKey){const[h]=d.refKey.split("/").map(parseFloat),y=a-h;if(y>0){const g=(1<<y)-1;this._tileClippers[f]=new ze.b(y,o&g,l&g,8,u)}}this._tileClippers[f]||(this._tileClippers[f]=new ze.I)}}_canParseStyleLayer(e){return!this._styleLayerUIDs||this._styleLayerUIDs.has(e)}parse(e){var t=this;return(0,le.Z)(function*(){const r=(0,ke.j)(),i=t._initialize(e),{returnedBuckets:n}=i;t._processLayers(i),t._linkReferences(i),t._filterFeatures(i);const a=[],o=new Set,l=(d,h)=>{o.has(d)||(a.push({name:d,repeat:h}),o.add(d))},u={};for(const d of n)d.getResources(d.tileClipper,l,u);if(t._tile.status===J.INVALID)return[];const f=t._fetchResources(a,u,e);return Promise.all([...f,r]).then(()=>t._processFeatures(i.returnedBuckets))})()}_initialize(e){return{signal:e&&e.signal,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(e){const{sourceNameToTileData:t,layers:r,zoom:i,sourceNameToTileClipper:n,sourceNameToUniqueSourceLayerBuckets:a,sourceNameToUniqueSourceLayers:o,returnedBuckets:l,layerIdToBucket:u,referencerUIDToReferencedId:f}=e;for(let d=r.length-1;d>=0;d--){const h=r[d];if(!this._canParseStyleLayer(h.uid)||h.minzoom&&i<Math.floor(h.minzoom)||h.maxzoom&&i>=h.maxzoom||h.type===V.fR.BACKGROUND||!t[h.source]||!n[h.source])continue;const g=n[h.source],m=h.sourceLayer,T=t[h.source][m];if(T){let x=o[h.source];if(x||(x=o[h.source]=new Set),x.add(h.sourceLayer),h.refLayerId)f.set(h.uid,h.refLayerId);else{const _=this._createBucket(h);if(_){_.layerUIDs=[h.uid],_.layerExtent=T.extent,_.tileClipper=g;let p=a[h.source];p||(p=a[h.source]={});let M=p[m];M||(M=p[m]=[]),M.push(_),l.push(_),u[h.id]=_}}}}}_linkReferences(e){const{layerIdToBucket:t,referencerUIDToReferencedId:r}=e;r.forEach((i,n)=>{t[i]&&t[i].layerUIDs.push(n)})}_filterFeatures(e){const{signal:t,sourceNameToTileData:r,sourceNameToUniqueSourceLayerBuckets:i,sourceNameToUniqueSourceLayers:n}=e,a=10*this._level,o=10*(this._level+1),l=[],u=[];for(const f of Object.keys(n))n[f].forEach(d=>{l.push(d),u.push(f)});for(let f=0;f<l.length;f++){const d=u[f],h=l[f];if(!r[d]||!i[d])continue;const y=r[d][h],g=i[d][h];if(!g||0===g.length)continue;if((0,me.Hc)(t))return;const m=y.getData();for(;m.nextTag(2);){const T=m.getMessage(),x=new Je(T,y);T.release();const _=x.values;if(_){const p=_._minzoom;if(p&&p>=o)continue;const M=_._maxzoom;if(M&&M<=a)continue}for(const p of g)p.pushFeature(x)}}}_fetchResources(e,t,r){const i=[],n=this._tile.getWorkerTileHandler();let a,o;e.length>0&&(a=n.fetchSprites(e,this._client,r),i.push(a));for(const l in t){const u=t[l];u.size>0&&(o=n.fetchGlyphs(this._tile.tileKey,l,u,this._client,r),i.push(o))}return i}_processFeatures(e){const t=e.filter(r=>r.hasFeatures()||this._canParseStyleLayer(r.layer.uid));for(const r of t)r.processFeatures(r.tileClipper);return t}_parseTileData(e){const t={};for(const r of Object.keys(e)){const i=e[r],n={};for(;i.next();)switch(i.tag()){case 3:{const a=i.getMessage(),o=new Ie(a);a.release(),n[o.name]=o;break}default:i.skip()}t[r]=n}return t}_createBucket(e){switch(e.type){case V.fR.BACKGROUND:return null;case V.fR.FILL:return this._createFillBucket(e);case V.fR.LINE:return this._createLineBucket(e);case V.fR.CIRCLE:return this._createCircleBucket(e);case V.fR.SYMBOL:return this._createSymbolBucket(e)}}_createFillBucket(e){return new Me(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new Qe(e.fillMaterial.getStride()),new re,new $e(e.outlineMaterial.getStride()),new re)}_createLineBucket(e){return new it(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new Xe(e.lineMaterial.getStride()),new re)}_createCircleBucket(e){return new et(e,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new qe(e.circleMaterial.getStride()),new re)}_createSymbolBucket(e){const t=this._tile;return new G(e,this._level,new Re(e.iconMaterial.getStride()),new re,new Re(e.textMaterial.getStride()),new re,t.placementEngine,t.getWorkerTileHandler())}}class ft{constructor(e,t,r,i){this.status=J.INITIALIZED,this.placementEngine=new je,this.tileKey=e,this.refKeys=t,this._workerTileHandler=r,this._styleRepository=i}release(){this.tileKey="",this.refKeys=null,this.status=J.INITIALIZED,this._workerTileHandler=null}parse(e,t){var r=this;return(0,le.Z)(function*(){const i=t&&t.signal;if((0,He.pC)(i)){const d=()=>{i.removeEventListener("abort",d),r.status=J.INVALID};i.addEventListener("abort",d)}let n;const a={bucketsWithData:[],emptyBuckets:null};try{n=yield r._parse(e,t)}catch(d){if((0,me.D_)(d))throw d;return{result:a,transferList:[]}}r.status=J.READY;const o=a.bucketsWithData,l=[];for(const d of n)if(d.hasFeatures()){const h=d.serialize();o.push(h)}else l.push(d.layer.uid);const u=[...o];let f=null;return l.length>0&&(f=Uint32Array.from(l),u.push(f.buffer)),a.emptyBuckets=f,{result:a,transferList:u}})()}setObsolete(){this.status=J.INVALID}getLayers(){return this._workerTileHandler.getLayers()}getWorkerTileHandler(){return this._workerTileHandler}_parse(e,t){var r=this;return(0,le.Z)(function*(){const i=e.sourceName2DataAndRefKey;return 0===Object.keys(i).length?[]:(r.status=J.MODIFIED,new ut(i,r,t.client,r._styleRepository,e.styleLayerUIDs).parse(t))})()}}var dt=C(78364);class yt{constructor(){this._spriteInfo={},this._glyphInfo={}}reset(){return this._spriteInfo={},this._glyphInfo={},Promise.resolve()}getLayers(){return this._styleRepository?.layers}createTileAndParse(e,t){var r=this;return(0,le.Z)(function*(){const{key:i}=e,n={};for(const o of Object.keys(e.sourceName2DataAndRefKey))n[o]=e.sourceName2DataAndRefKey[o].refKey;const a=new ft(i,n,r,r._styleRepository);try{return yield a.parse(e,t)}catch(o){if(a.setObsolete(),a.release(),!(0,me.D_)(o))throw o;return null}})()}updateStyle(e){if(!e||0===e.length||!this._styleRepository)return;const t=this._styleRepository;for(const r of e){const n=r.data;switch(r.type){case Y.Fr.PAINTER_CHANGED:t.setPaintProperties(n.layer,n.paint);break;case Y.Fr.LAYOUT_CHANGED:t.setLayoutProperties(n.layer,n.layout);break;case Y.Fr.LAYER_REMOVED:t.deleteStyleLayer(n.layer);break;case Y.Fr.LAYER_CHANGED:t.setStyleLayer(n.layer,n.index);break;case Y.Fr.SPRITES_CHANGED:this._spriteInfo={}}}}setStyle(e){this._styleRepository=new dt.Z(e),this._spriteInfo={},this._glyphInfo={}}fetchSprites(e,t,r){const i=[],n=this._spriteInfo;for(const a of e)void 0===n[a.name]&&i.push(a);return 0===i.length?Promise.resolve():t.invoke("getSprites",i,{signal:r&&r.signal}).then(a=>{for(const o in a)n[o]=a[o]})}getSpriteItems(){return this._spriteInfo}fetchGlyphs(e,t,r,i,n){const a=[];let o=this._glyphInfo[t];return o?r.forEach(l=>{o[l]||a.push(l)}):(o=this._glyphInfo[t]=[],r.forEach(l=>a.push(l))),0===a.length?Promise.resolve():i.invoke("getGlyphs",{tileID:e,font:t,codePoints:a},n).then(l=>{for(let u=0;u<l.length;u++)l[u]&&(o[u]=l[u])})}getGlyphItems(e){return this._glyphInfo[e]}}}}]);