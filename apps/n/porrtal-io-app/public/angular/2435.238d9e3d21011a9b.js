"use strict";(self.webpackChunka_porrtal_io_app=self.webpackChunka_porrtal_io_app||[]).push([[2435],{12435:(Se,gt,f)=>{f.r(gt),f.d(gt,{meshFeatureSetFromJSON:()=>Fe});var zt=f(88879),l=f(62208),rt=f(2004),z=f(15861),M=f(17626),ot=f(26584),Tt=f(80542),Ut=f(47996),C=f(63290),Dt=f(60330),$=f(10699),jt=f(32917),R=f(77712),$t=(f(85931),f(90912),f(76898)),d=f(28093),Gt=f(21674),E=f(72642),Nt=f(37118),A=f(89586),G=f(61751),k=f(99746),q=f(92529),Bt=f(85334),S=f(55915),_=f(92545),st=f(60853);const it=C.Z.getLogger("esri.geometry.support.meshUtils.centerAt");const Vt=(0,d.c)(),Jt=(0,d.c)();var mt=f(21726);function at(){return(at=(0,z.Z)(function*(t,n,e){const{loadGLTFMesh:r}=yield(0,$.Hl)(f.e(9185).then(f.bind(f,29185)),e),o=yield dt(n,e),s=r(new E.Z({x:0,y:0,z:0,spatialReference:t.spatialReference}),o.url,{resolveFile:kt(o),useTransform:!0,signal:(0,l.pC)(e)?e.signal:null});s.then(()=>o.dispose(),()=>o.dispose());const{vertexAttributes:i,components:a}=yield s;t.vertexAttributes=i,t.components=a})).apply(this,arguments)}function kt(t){const n=(0,mt.Yd)(t.url);return e=>{const r=(0,mt.PF)(e,n,n),o=r?r.replace(/^ *\.\//,""):null;return(o?t.files.get(o):null)??e}}function dt(t,n){return lt.apply(this,arguments)}function lt(){return(lt=(0,z.Z)(function*(t,n){return t instanceof Blob?N.fromBlob(t):"string"==typeof t?new N(t):Array.isArray(t)?qt(t,n):_t(t,n)})).apply(this,arguments)}function qt(t,n){return ct.apply(this,arguments)}function ct(){return ct=(0,z.Z)(function*(t,n){const e=new Map;let r=null;const o=yield(0,$.WW)(t.map(function(){var i=(0,z.Z)(function*(a){return{name:a.name,source:yield dt(a instanceof Blob?a:a.source,n)}});return function(a){return i.apply(this,arguments)}}())),s=[];for(const i of o)i&&((0,$.Hc)(n)?i.source.dispose():s.push(i));(0,$.k_)(n);for(const{name:i,source:a}of s)((0,l.Wi)(r)||/\.(gltf|glb)/i.test(i))&&(r=a.url),e.set(i,a.url),a.files&&a.files.forEach((c,u)=>e.set(u,c));if((0,l.Wi)(r))throw new ot.Z("mesh-load-external:missing-files","Missing files to load external mesh source");return new N(r,()=>s.forEach(({source:i})=>i.dispose()),e)}),ct.apply(this,arguments)}function _t(t,n){return ft.apply(this,arguments)}function ft(){return ft=(0,z.Z)(function*(t,n){const{default:e}=yield(0,$.Hl)(Promise.resolve().then(f.bind(f,84792)),n),r="string"==typeof t.multipart[0]?yield Promise.all(t.multipart.map(function(){var o=(0,z.Z)(function*(s){return(yield e(s,{responseType:"array-buffer"})).data});return function(s){return o.apply(this,arguments)}}())):t.multipart;return N.fromBlob(new Blob(r))}),ft.apply(this,arguments)}class N{constructor(n,e=(()=>{}),r=new Map){this.url=n,this.dispose=e,this.files=r}static fromBlob(n){const e=URL.createObjectURL(n);return new N(e,()=>URL.revokeObjectURL(e))}}var xt=f(30217),pt=f(550),vt=f(43703),y=f(84161),ut=f(12080),v=f(65231);function yt(t,n){if(t)for(let e=0;e<t.length;e+=3)for(let r=0;r<3;r++)t[e+r]+=n[r]}const oe=(0,d.c)(),Ct=(0,vt.c)(),At=(0,pt.c)(),Q={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function tt(t,n,e){t.isPlane||function pe(t){for(let n=0;n<t.position.length;n+=3)t.position[n+2]+=.5}(t),function ue(t,n){if(null==n)return;const e="number"==typeof n?[n,n,n]:[null!=n.width?n.width:1,null!=n.depth?n.depth:1,null!=n.height?n.height:1];T[0]=e[0],T[4]=e[1],T[8]=e[2];for(let r=0;r<t.position.length;r+=3){for(let o=0;o<3;o++)x[o]=t.position[r+o];(0,y.t)(x,x,T);for(let o=0;o<3;o++)t.position[r+o]=x[o]}if(e[0]!==e[1]||e[1]!==e[2]){T[0]=1/e[0],T[4]=1/e[1],T[8]=1/e[2];for(let r=0;r<t.normal.length;r+=3){for(let o=0;o<3;o++)x[o]=t.normal[r+o];(0,y.t)(x,x,T),(0,y.n)(x,x);for(let o=0;o<3;o++)t.normal[r+o]=x[o]}}}(t,e?.size);const{vertexAttributes:r,transform:o}=(0,st.w1)(t,n,e);return{vertexAttributes:new q.Q({...r,uv:t.uv}),transform:o,components:[new G.Z({faces:t.faces,material:e&&e.material||null})],spatialReference:n.spatialReference}}const he={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},ge={south:0,east:1,north:2,west:3,up:4,down:5},x=(0,d.c)(),T=(0,pt.c)();var me=f(28347);const bt=C.Z.getLogger("esri.geometry.support.meshUtils.rotate");function K(t,n,e,r=d.Z){if(!(0,l.Wi)(t)){(0,me.d)(et,(0,A.WH)(n),(0,A.ZZ)(n));for(let o=0;o<t.length;o+=e){for(let s=0;s<3;s++)H[s]=t[o+s]-r[s];(0,y.m)(H,H,et);for(let s=0;s<3;s++)t[o+s]=H[s]+r[s]}}}const H=(0,d.c)(),wt=(0,d.c)(),Zt=(0,A.Ue)(),et=(0,vt.c)(),Ft=(0,pt.c)(),Mt=(0,d.c)(),Rt=C.Z.getLogger("esri.geometry.support.meshUtils.scale");function Pt(t,n,e=d.Z){if(t)for(let r=0;r<t.length;r+=3){for(let o=0;o<3;o++)X[o]=t[r+o]-e[o];(0,y.g)(X,X,n);for(let o=0;o<3;o++)t[r+o]=X[o]+e[o]}}const X=(0,d.c)(),Lt=(0,d.c)(),Ot=(0,d.c)();var P;const j="esri.geometry.Mesh";let w=P=class extends((0,Tt.p)(Ut.Z.LoadableMixin((0,Dt.v)(Gt.Z)))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new q.Q,this.type="mesh"}initialize(){((0,l.Wi)(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.handles.add((0,jt.YP)(()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map(t=>t.clone())}),()=>this._set("external",null),{once:!0,sync:!0}))})}get hasExtent(){return!this.loaded&&(0,l.pC)(this.external)&&(0,l.pC)(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get _boundingInfo(){const t=this.vertexAttributes.position,n=this.spatialReference;if(0===t.length||this.components&&0===this.components.length)return{extent:new rt.Z({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:n}),center:new E.Z({x:0,y:0,z:0,spatialReference:n})};const e=(0,l.pC)(this.transform)?this.transform.project(t,n):t;let r=1/0,o=1/0,s=1/0,i=-1/0,a=-1/0,c=-1/0,u=0,p=0,g=0;const m=e.length,h=1/(m/3);let Z=0;for(;Z<m;){const I=e[Z++],b=e[Z++],L=e[Z++];r=Math.min(r,I),o=Math.min(o,b),s=Math.min(s,L),i=Math.max(i,I),a=Math.max(a,b),c=Math.max(c,L),u+=h*I,p+=h*b,g+=h*L}return{extent:new rt.Z({xmin:r,ymin:o,zmin:s,xmax:i,ymax:a,zmax:c,spatialReference:n}),center:new E.Z({x:u,y:p,z:g,spatialReference:n})}}get anchor(){if((0,l.pC)(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this._boundingInfo;return new E.Z({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return(0,l.pC)(this.transform)?this.transform.getOriginPoint(this.spatialReference):this._boundingInfo.center}get extent(){return!this.loaded&&(0,l.pC)(this.external)&&(0,l.pC)(this.external.extent)?this.external.extent.clone():this._boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(G.Z.from(t)),this.notifyChange("components")):C.Z.getLogger(this.declaredClass).error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const n=this.components.indexOf(t);if(-1!==n)return this.components.splice(n,1),void this.notifyChange("components")}C.Z.getLogger(this.declaredClass).error("removeComponent()","Provided component is not part of the list of components")}else C.Z.getLogger(this.declaredClass).error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,n,e,r){return(0,A.uT)(ht.x,t,V),(0,A.uT)(ht.y,n,Et),(0,A.uT)(ht.z,e,St),(0,A.qC)(V,Et,V),(0,A.qC)(V,St,V),function de(t,n,e){if(!t.vertexAttributes||!t.vertexAttributes.position||0===n[3])return;const r=t.spatialReference;if((0,l.pC)(t.transform)){null!=e?.geographic&&e.geographic!==t.transform.geographic&&bt.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=e?.origin??t.transform.getOriginPoint(r);!function xe(t,n,e){const r=(0,y.s)(H,e.x,e.y,e.z),o=(0,y.b)(H,r,t.origin);t.applyLocalInverse(o,wt),t.rotation=(0,A.qC)(t.rotation,n,(0,A.Ue)()),t.applyLocalInverse(o,o),(0,y.b)(o,o,wt),t.translation=(0,y.a)((0,d.c)(),t.translation,o)}(t.transform,n,o)}else{const o=e?.origin??t.origin;(0,_.h)(t.spatialReference,e)?function ve(t,n,e){const r=t.spatialReference,o=(0,ut.rS)(r),s=Mt;(0,S.KC)(e,s,o)||(0,S.KC)(t.origin,s,o);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,u=new Float64Array(i.length),p=(0,l.pC)(a)?new Float32Array(a.length):null,g=(0,l.pC)(c)?new Float32Array(c.length):null;(0,S.Bm)(o,s,et,o),(0,xt.f)(Ft,et);const m=Zt;(0,y.t)((0,A.ZZ)(Zt),(0,A.ZZ)(n),Ft),m[3]=n[3],(0,v.XO)(i,r,u),(0,l.pC)(a)&&(0,l.pC)(p)&&(0,v.Iz)(a,i,u,r,p),(0,l.pC)(c)&&(0,l.pC)(g)&&(0,v.wi)(c,i,u,r,g),K(u,m,3,s),(0,v.To)(u,i,r),(0,l.pC)(a)&&(0,l.pC)(p)&&(K(p,m,3),(0,v.Yk)(p,i,u,r,a)),(0,l.pC)(c)&&(0,l.pC)(g)&&(K(g,m,4),(0,v.M2)(g,i,u,r,c)),t.vertexAttributesChanged()}(t,n,o):function ye(t,n,e){const r=Mt;if(!(0,S.KC)(e,r,t.spatialReference)){const o=t.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,bt.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}K(t.vertexAttributes.position,n,3,r),K(t.vertexAttributes.normal,n,3),K(t.vertexAttributes.tangent,n,4),t.vertexAttributesChanged()}(t,n,o)}}(this,V,r),this}offset(t,n,e,r){return this.loaded?(nt[0]=t,nt[1]=n,nt[2]=e,function te(t,n,e){t.vertexAttributes&&t.vertexAttributes.position&&((0,l.pC)(t.transform)?(null!=e?.geographic&&e.geographic!==t.transform.geographic&&C.Z.getLogger("esri.geometry.support.meshUtils.offset").warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function ee(t,n){const e=t.origin;t.origin=(0,y.a)((0,d.c)(),e,n)}(t.transform,n)):(0,_.h)(t.spatialReference,e)?function ne(t,n){const e=t.spatialReference,r=t.vertexAttributes.position,o=t.vertexAttributes.normal,s=t.vertexAttributes.tangent,i=new Float64Array(r.length),a=(0,l.pC)(o)?new Float32Array(o.length):null,c=(0,l.pC)(s)?new Float32Array(s.length):null,u=t.extent.center,p=oe;(0,S.Bm)(e,[u.x,u.y,u.z],Ct,(0,ut.rS)(e)),(0,xt.f)(At,Ct),(0,y.t)(p,n,At),(0,v.XO)(r,e,i),(0,l.pC)(o)&&(0,l.pC)(a)&&(0,v.Iz)(o,r,i,e,a),(0,l.pC)(s)&&(0,l.pC)(c)&&(0,v.wi)(s,r,i,e,c),yt(i,p),(0,v.To)(i,r,e),(0,l.pC)(o)&&(0,l.pC)(a)&&(0,v.Yk)(a,r,i,e,o),(0,l.pC)(s)&&(0,l.pC)(c)&&(0,v.M2)(c,r,i,e,s),t.vertexAttributesChanged()}(t,n):function re(t,n){yt(t.vertexAttributes.position,n),t.vertexAttributesChanged()}(t,n))}(this,nt,r),this):(C.Z.getLogger(this.declaredClass).error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,n){return this.loaded?(function Ce(t,n,e){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=t.spatialReference;if((0,l.pC)(t.transform)){null!=e?.geographic&&e.geographic!==t.transform.geographic&&Rt.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=e?.origin??t.transform.getOriginPoint(r);!function Ae(t,n,e){const r=(0,y.s)(X,e.x,e.y,e.z),o=(0,y.b)(X,r,t.origin);t.applyLocalInverse(o,Lt);const s=(0,y.g)((0,d.c)(),t.scale,n);t.scale=s,t.applyLocalInverse(o,o),(0,y.b)(o,o,Lt),t.translation=(0,y.a)((0,d.c)(),t.translation,o)}(t.transform,n,o)}else{const o=(0,_.h)(t.spatialReference,e),s=e&&e.origin||t.origin;o?function be(t,n,e){const r=t.spatialReference,o=(0,ut.rS)(r),s=Ot;(0,S.KC)(e,s,o)||(0,S.KC)(t.origin,s,o);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,u=new Float64Array(i.length),p=(0,l.pC)(a)?new Float32Array(a.length):null,g=(0,l.pC)(c)?new Float32Array(c.length):null;(0,v.XO)(i,r,u),(0,l.pC)(a)&&(0,l.pC)(p)&&(0,v.Iz)(a,i,u,r,p),(0,l.pC)(c)&&(0,l.pC)(g)&&(0,v.wi)(c,i,u,r,g),Pt(u,n,s),(0,v.To)(u,i,r),(0,l.pC)(a)&&(0,l.pC)(p)&&(0,v.Yk)(p,i,u,r,a),(0,l.pC)(c)&&(0,l.pC)(g)&&(0,v.M2)(g,i,u,r,c),t.vertexAttributesChanged()}(t,n,s):function we(t,n,e){const r=Ot;if(!(0,S.KC)(e,r,t.spatialReference)){const o=t.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,Rt.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Pt(t.vertexAttributes.position,n,r),t.vertexAttributesChanged()}(t,n,s)}}(this,t,n),this):(C.Z.getLogger(this.declaredClass).error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,n){return this.loaded?(function Wt(t,n,e){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=e?.origin??t.origin;(0,l.pC)(t.transform)?(null!=e?.geographic&&e.geographic!==t.transform.geographic&&it.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function Yt(t,n,e){const i=t.origin;t.origin=[i[0]+(n.x-e.x),i[1]+(n.y-e.y),i[2]+(n.hasZ&&e.hasZ?n.z-e.z:0)]}(t.transform,n,r)):(0,_.h)(t.spatialReference,e)?function Kt(t,n,e){const r=(0,st.FF)(t.vertexAttributes,e,{geographic:!0}),{position:o,normal:s,tangent:i}=(0,st.iv)(r,n,{geographic:!0});t.vertexAttributes.position=o,t.vertexAttributes.normal=s,t.vertexAttributes.tangent=i,t.vertexAttributesChanged()}(t,n,r):function Ht(t,n,e){const r=Jt,o=Vt;if((0,S.KC)(n,o,t.spatialReference)){if(!(0,S.KC)(e,r,t.spatialReference)){const s=t.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,it.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}(function Xt(t,n,e){if(t)for(let r=0;r<t.length;r+=3)for(let o=0;o<3;o++)t[r+o]+=n[o]-e[o]})(t.vertexAttributes.position,o,r),t.vertexAttributesChanged()}else it.error(`Failed to project centerAt location (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`)}(t,n,r)}(this,t,n),this):(C.Z.getLogger(this.declaredClass).error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return(0,l.pC)(this.external)&&this.addResolvingPromise(function Qt(t,n,e){return at.apply(this,arguments)}(this,this.external.source,t)),Promise.resolve(this)}updateExternalSource(t){this._set("external",t)}clone(){let t=null;if(this.components){const e=new Map,r=new Map;t=this.components.map(o=>o.cloneWithDeduplication(e,r))}const n={components:t,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:(0,l.pC)(this.transform)?this.transform.clone():null,external:(0,l.pC)(this.external)?{source:this.external.source,extent:(0,l.pC)(this.external.extent)?this.external.extent.clone():null}:null};return new P(n)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}toBinaryGLTF(t){var n=this;return(0,z.Z)(function*(){const e=f.e(4367).then(f.bind(f,54367)),r=n.load(),o=yield Promise.all([e,r]),{toBinaryGLTF:s}=o[0];return s(n,t)})()}static createBox(t,n){if(!(t instanceof E.Z))return C.Z.getLogger(j).error(".createBox()","expected location to be a Point instance"),null;const e=new P(tt(function se(){const{faceDescriptions:t,faceVertexOffsets:n,uvScales:e}=he,r=4*t.length,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(2*t.length*3);let c=0,u=0,p=0,g=0;for(let m=0;m<t.length;m++){const h=t[m],Z=c/3;for(const b of n)a[g++]=Z+b;const I=h.corners;for(let b=0;b<4;b++){const L=I[b];let F=0;i[p++]=.25*e[b][0]+h.uvOrigin[0],i[p++]=h.uvOrigin[1]-.25*e[b][1];for(let O=0;O<3;O++)0!==h.axis[O]?(o[c++]=.5*h.axis[O],s[u++]=h.axis[O]):(o[c++]=.5*L[F++],s[u++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),t,n));return n&&n.imageFace&&"all"!==n.imageFace?function ie(t,n){const e=t.components[0],r=e.faces,o=ge[n],s=6*o,i=new Array(6),a=new Array(r.length-6);let c=0,u=0;for(let p=0;p<r.length;p++)p>=s&&p<s+6?i[c++]=r[p]:a[u++]=r[p];if((0,l.pC)(t.vertexAttributes.uv)){const p=new Float32Array(t.vertexAttributes.uv),g=4*o*2,m=[0,1,1,1,1,0,0,0];for(let h=0;h<m.length;h++)p[g+h]=m[h];t.vertexAttributes.uv=p}return t.components=[new G.Z({faces:i,material:e.material}),new G.Z({faces:a})],t}(e,n.imageFace):e}static createSphere(t,n){return t instanceof E.Z?new P(tt(function ae(t=0){const n=Math.round(8*2**t),e=2*n,r=(n-1)*(e+1)+2*e,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array((n-1)*e*2*3);let c=0,u=0,p=0,g=0;for(let m=0;m<=n;m++){const h=m/n*Math.PI+.5*Math.PI,Z=Math.cos(h),I=Math.sin(h);x[2]=I;const b=0===m||m===n,L=b?e-1:e;for(let F=0;F<=L;F++){const O=F/L*2*Math.PI;x[0]=-Math.sin(O)*Z,x[1]=Math.cos(O)*Z;for(let D=0;D<3;D++)o[c]=.5*x[D],s[c]=x[D],++c;i[u++]=(F+(b?.5:0))/e,i[u++]=m/n,0!==m&&F!==e&&(m!==n&&(a[p++]=g,a[p++]=g+1,a[p++]=g-e),1!==m&&(a[p++]=g,a[p++]=g-e,a[p++]=g-e-1)),g++}}return{position:o,normal:s,uv:i,faces:a}}(n&&n.densificationFactor||0),t,n)):(C.Z.getLogger(j).error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,n){return t instanceof E.Z?new P(tt(function le(t=0){const e=Math.round(16*2**t),r=4*(e+1)+2*e,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(4*e*3);let c=0,u=0,p=0,g=0,m=0;for(let h=0;h<=5;h++){const Z=0===h||5===h,I=h<=1||h>=4,b=2===h||4===h,L=Z?e-1:e;for(let F=0;F<=L;F++){const O=F/L*2*Math.PI,D=Z?0:.5;x[0]=D*Math.sin(O),x[1]=D*-Math.cos(O),x[2]=h<=2?.5:-.5;for(let J=0;J<3;J++)o[c++]=x[J],s[u++]=I?2===J?h<=1?1:-1:0:2===J?0:x[J]/D;i[p++]=(F+(Z?.5:0))/e,i[p++]=h<=1?1*h/3:h<=3?1*(h-2)/3+1/3:1*(h-4)/3+2/3,b||0===h||F===e||(5!==h&&(a[g++]=m,a[g++]=m+1,a[g++]=m-e),1!==h&&(a[g++]=m,a[g++]=m-e,a[g++]=m-e-1)),m++}}return{position:o,normal:s,uv:i,faces:a}}(n&&n.densificationFactor||0),t,n)):(C.Z.getLogger(j).error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,n){if(!(t instanceof E.Z))return C.Z.getLogger(j).error(".createPlane()","expected location to be a Point instance"),null;const e=n?.facing??"up",r=function ce(t,n){const e="number"==typeof n?n:null!=n?n.width:1,r="number"==typeof n?n:null!=n?n.height:1;switch(t){case"up":case"down":return{width:e,depth:r};case"north":case"south":return{width:e,height:r};case"east":case"west":return{depth:e,height:r}}}(e,n?.size);return new P(tt(function fe(t){const n=Q.facingAxisOrderSwap[t],e=Q.position,r=Q.normal,o=new Float64Array(e.length),s=new Float32Array(r.length);let i=0;for(let a=0;a<4;a++){const c=i;for(let u=0;u<3;u++){const p=n[u],g=Math.abs(p)-1,m=p>=0?1:-1;o[i]=e[c+g]*m,s[i]=r[c+g]*m,i++}}return{position:o,normal:s,uv:new Float32Array(Q.uv),faces:new Uint32Array(Q.faces),isPlane:!0}}(e),t,{...n,size:r}))}static createFromPolygon(t,n){if(!(t instanceof Nt.Z))return C.Z.getLogger(j).error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const e=(0,Bt.bT)(t);return new P({vertexAttributes:new q.Q({position:e.position}),components:[new G.Z({faces:e.faces,shading:"flat",material:n?.material??null})],spatialReference:t.spatialReference})}static createFromGLTF(t,n,e){return(0,z.Z)(function*(){if(!(t instanceof E.Z))throw C.Z.getLogger(j).error(".createfromGLTF()","expected location to be a Point instance"),new ot.Z("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=yield(0,$.Hl)(f.e(9185).then(f.bind(f,29185)),e);return new P(yield r(t,n,e))})()}static createWithExternalSource(t,n,e){const r=e?.extent??null,o=e?.transform?.clone()??new k.Z;return o.origin=[t.x,t.y,t.z??0],new P({external:{source:n,extent:r},transform:o,spatialReference:t.spatialReference})}static createIncomplete(t,n){const e=n?.transform?.clone()??new k.Z;e.origin=[t.x,t.y,t.z??0];const o=new P({transform:e,spatialReference:t.spatialReference});return o.addResolvingPromise(Promise.reject(new ot.Z("mesh-incomplete","Mesh resources are not complete"))),o}};(0,M._)([(0,R.Cb)({type:[G.Z],json:{write:!0}})],w.prototype,"components",void 0),(0,M._)([(0,R.Cb)({type:k.Z,json:{write:!0}})],w.prototype,"transform",void 0),(0,M._)([(0,R.Cb)({constructOnly:!0})],w.prototype,"external",void 0),(0,M._)([(0,R.Cb)({readOnly:!0})],w.prototype,"hasExtent",null),(0,M._)([(0,R.Cb)({readOnly:!0})],w.prototype,"_boundingInfo",null),(0,M._)([(0,R.Cb)({readOnly:!0})],w.prototype,"anchor",null),(0,M._)([(0,R.Cb)({readOnly:!0})],w.prototype,"origin",null),(0,M._)([(0,R.Cb)({readOnly:!0,json:{read:!1}})],w.prototype,"extent",null),(0,M._)([(0,R.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!0}})],w.prototype,"hasZ",void 0),(0,M._)([(0,R.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!1}})],w.prototype,"hasM",void 0),(0,M._)([(0,R.Cb)({type:q.Q,nonNullable:!0,json:{write:!0}})],w.prototype,"vertexAttributes",void 0),w=P=(0,M._)([(0,$t.j)(j)],w);const ht={x:(0,d.f)(1,0,0),y:(0,d.f)(0,1,0),z:(0,d.f)(0,0,1)},V=(0,A.Ue)(),Et=(0,A.Ue)(),St=(0,A.Ue)(),nt=(0,d.c)(),It=w;var U,t,Ze=f(17253);function Fe(t,n,e){const r=e.features;e.features=[],delete e.geometryType;const o=Ze.default.fromJSON(e);if(o.geometryType="mesh",!e.assetMaps)return o;const s=function Oe(t,n){const e=new Map;for(const r of n){const o=r.parentGlobalId;if(null==o)continue;const s=r.assetName,i=r.assetURL,a=r.conversionStatus;let c=e.get(o);if(null!=c)throw new Error("multiple asset parts not expected.");switch(c={name:s,status:U.FAILED,url:i,geographic:Ee(r.flags).projectVertices},e.set(o,c),a){case"COMPLETED":case"SUBMITTED":c.status=U.COMPLETED;break;case"INPROGRESS":c.status=U.PENDING;break;default:c.status=U.FAILED}}return e}(0,e.assetMaps),i=o.spatialReference,a=e.globalIdFieldName,c=(0,l.Wi)(t.outFields)||!t.outFields.length?()=>({}):function Me(t){return({attributes:n})=>{if(!n)return{};if(!t)return n;for(const e in n)t.has(e)||delete n[e];return n}}(t.outFields.includes("*")?null:new Set(t.outFields));for(const u of r){const p=Re(u,a,i,n,s);(0,l.pC)(p)&&o.features.push(new zt.Z({geometry:p,attributes:c(u)}))}return o}function Re(t,n,e,r,o){const i=o.get(t.attributes[n]);if(null==i||i.status===U.FAILED||null==i.url)return null;const a=function Pe({attributes:t},n,{transformFieldRoles:e}){return new E.Z({x:t[e.originX],y:t[e.originY],z:t[e.originZ],spatialReference:n})}(t,e,r),c=rt.Z.fromJSON(t.geometry);c.spatialReference=e;const u=function Le(t,{transformFieldRoles:n},e){return new k.Z({translation:[t[n.translationX],t[n.translationY],t[n.translationZ]],rotation:(0,A.uT)([t[n.rotationX],t[n.rotationY],t[n.rotationZ]],t[n.rotationDeg]),scale:[t[n.scaleX],t[n.scaleY],t[n.scaleZ]],geographic:e})}(t.attributes,r,i.geographic);return i.status===U.PENDING?It.createIncomplete(a,{extent:c,transform:u}):It.createWithExternalSource(a,[{name:i.name,source:i.url}],{extent:c,transform:u})}function Ee(t){return{projectVertices:t.includes("PROJECT_VERTICES")}}(t=U||(U={}))[t.FAILED=0]="FAILED",t[t.PENDING=1]="PENDING",t[t.COMPLETED=2]="COMPLETED"}}]);