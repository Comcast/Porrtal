/*
Copyright 2022 Comcast Cable Communications Management, LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
"use strict";(self.webpackChunka_porrtal_io_app=self.webpackChunka_porrtal_io_app||[]).push([[921],{26996:(de,ee,f)=>{f.d(ee,{Y:()=>b,m:()=>$});var W=f(36161),G=f(21286);function b(F,V,oe){const J=(0,G.fp)(Math.ceil(oe)),N=(F=>"vertical"===F||"horizontal"===F||"cross"===F||"esriSFSCross"===F||"esriSFSVertical"===F||"esriSFSHorizontal"===F)(V)?8*J:16*J,M=2*J;F.width=N,F.height=N;const E=F.getContext("2d");E.strokeStyle="#FFFFFF",E.lineWidth=J,E.beginPath(),"vertical"!==V&&"cross"!==V&&"esriSFSCross"!==V&&"esriSFSVertical"!==V||(E.moveTo(N/2,-M),E.lineTo(N/2,N+M)),"horizontal"!==V&&"cross"!==V&&"esriSFSCross"!==V&&"esriSFSHorizontal"!==V||(E.moveTo(-M,N/2),E.lineTo(N+M,N/2)),"forward-diagonal"!==V&&"diagonal-cross"!==V&&"esriSFSDiagonalCross"!==V&&"esriSFSForwardDiagonal"!==V||(E.moveTo(-M,-M),E.lineTo(N+M,N+M),E.moveTo(N-M,-M),E.lineTo(N+M,M),E.moveTo(-M,N-M),E.lineTo(M,N+M)),"backward-diagonal"!==V&&"diagonal-cross"!==V&&"esriSFSBackwardDiagonal"!==V&&"esriSFSDiagonalCross"!==V||(E.moveTo(N+M,-M),E.lineTo(-M,N+M),E.moveTo(M,-M),E.lineTo(-M,M),E.moveTo(N+M,N-M),E.lineTo(N-M,N+M)),E.stroke();const B=E.getImageData(0,0,F.width,F.height),U=new Uint8Array(B.data);let A;for(let j=0;j<U.length;j+=4)A=U[j+3]/255,U[j]=U[j]*A,U[j+1]=U[j+1]*A,U[j+2]=U[j+2]*A;return[U,F.width,F.height]}function $(F,V){const oe="Butt"===V,J="Square"===V,N=!oe&&!J;F.length%2==1&&(F=[...F,...F]);const M=15.5;let B=0;for(const le of F)B+=le;const U=Math.round(B*M),A=new Float32Array(31*U),j=7.75;let Z=0,w=0,u=.5,K=!0;for(const le of F){for(Z=w,w+=le*M;u<=w;){let ae=.5;for(;ae<31;){const Pe=(ae-.5)*U+u-.5,se=N?(ae-M)*(ae-M):Math.abs(ae-M);A[Pe]=K?oe?Math.max(Math.max(Z+j-u,se),Math.max(u-w+j,se)):se:N?Math.min((u-Z)*(u-Z)+se,(u-w)*(u-w)+se):J?Math.min(Math.max(u-Z,se),Math.max(w-u,se)):Math.min(Math.max(u-Z+j,se),Math.max(w+j-u,se)),ae++}u++}K=!K}const Q=A.length,be=new Uint8Array(4*Q);for(let le=0;le<Q;++le){const ae=(N?Math.sqrt(A[le]):A[le])/M;(0,W.I)(ae,be,4*le)}return[be,U,31]}},86575:(de,ee,f)=>{f.d(ee,{B1:()=>W,DQ:()=>E,DT:()=>oe,JJ:()=>G,Or:()=>B,_U:()=>X,k3:()=>A,sX:()=>Z});const W=Number.POSITIVE_INFINITY,G=Math.PI,X=2*G,$=128/G,oe=G/180,M=1/Math.LN2;function E(u,K){return(u%=K)>=0?u:u+K}function B(u){return E(u*$,256)}function A(u){return Math.log(u)*M}function Z(u,K,Q){return u*(1-Q)+K*Q}},43289:(de,ee,f)=>{function U(u){return function E(u,K){return(u%=K)>=0?u:u+K}(.7111111111111111*u,256)}function w(u,K,Q){return u>=K&&u<=Q||u>=Q&&u<=K}f.d(ee,{s5:()=>U,vX:()=>w}),Math,Math},84439:(de,ee,f)=>{f.d(ee,{Z:()=>W});class W{constructor(X=0,b=0,$=0,F=0){this.x=X,this.y=b,this.width=$,this.height=F}get isEmpty(){return this.width<=0||this.height<=0}union(X){this.x=Math.min(this.x,X.x),this.y=Math.min(this.y,X.y),this.width=Math.max(this.width,X.width),this.height=Math.max(this.height,X.height)}}},5254:(de,ee,f)=>{f.d(ee,{Au:()=>E,Jz:()=>A,UJ:()=>U});const W=new Float32Array(1);function E(w){return[255&w,(65280&w)>>>8,(16711680&w)>>>16,(4278190080&w)>>>24]}function U(w,u){return 65535&w|u<<16}function A(w,u,K,Q){return 255&w|(255&u)<<8|(255&K)<<16|Q<<24}new Uint32Array(W.buffer)},19702:(de,ee,f)=>{f.d(ee,{A:()=>M});var W=f(15861),G=f(17626),X=f(54024),b=f(10699),$=f(32917),F=f(77712),J=(f(85931),f(90912),f(76898)),N=f(36947);const M=E=>{let B=class extends E{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.supportsHeightUnitConversion=!1}postscript(U){super.postscript(U),(0,N.qC)(this.layer)&&this.addResolvingPromise(this._validateHeightModelInfo())}_validateHeightModelInfo(){var U=this;return(0,W.Z)(function*(){const A=new AbortController,j=A.signal;U.handles.add((0,X.kB)(()=>A.abort())),yield(0,$.N1)(()=>U.view.defaultsFromMap?.heightModelInfoReady,j),(0,b.k_)(j);const Z=(0,N.Wt)(U.layer,U.view.heightModelInfo,U.supportsHeightUnitConversion);if(Z)throw Z})()}canResume(){const U=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return super.canResume()&&(!U||!U.minScale||!U.maxScale||U.minScale>=U.maxScale)}getSuspendInfo(){const U=super.getSuspendInfo(),A=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return A&&A.minScale&&A.maxScale&&A.minScale<A.maxScale&&(U.outsideScaleRange=!0),U}};return(0,G._)([(0,F.Cb)()],B.prototype,"view",void 0),(0,G._)([(0,F.Cb)()],B.prototype,"slicePlaneEnabled",void 0),B=(0,G._)([(0,J.j)("esri.views.3d.layers.LayerView3D")],B),B}},63038:(de,ee,f)=>{f.r(ee),f.d(ee,{default:()=>Lt});var W=f(15861),G=f(17626),X=f(26584),b=f(62208),$=f(10699),F=f(32917),V=f(77712),N=(f(85931),f(90912),f(76898));class M{constructor(e,i){this._lockedSchemaPixelSize=e,this._isGCS=i}getLevelRowColumn(e){return this._isGCS?[e[0],e[1]>>1,e[2]>>1]:256===this._lockedSchemaPixelSize&&e[0]>0?[e[0]-1,e[1]>>1,e[2]>>1]:e}adjustLevel(e){return this._isGCS?e:256===this._lockedSchemaPixelSize?e>0?e-1:0:e}getShift(e,i){let t=0,n=0;return(256===this._lockedSchemaPixelSize||this._isGCS)&&(e[2]%2&&(t=i),e[1]%2&&(n=i)),[t,n]}getScale(e){if(this._isGCS){if(512===this._lockedSchemaPixelSize)return 4}else if(256===this._lockedSchemaPixelSize&&0===e)return 1;return 2}}var E=f(1036),B=f(49966),U=f(65401),A=f(21726),j=f(59289),Z=f(84439);class w{constructor(e,i){this._width=0,this._height=0,this._free=[],this._width=e,this._height=i,this._free.push(new Z.Z(0,0,e,i))}get width(){return this._width}get height(){return this._height}allocate(e,i){if(e>this._width||i>this._height)return new Z.Z;let t=null,n=-1;for(let r=0;r<this._free.length;++r){const o=this._free[r];e<=o.width&&i<=o.height&&(null===t||o.y<=t.y&&o.x<=t.x)&&(t=o,n=r)}return null===t?new Z.Z:(this._free.splice(n,1),t.width<t.height?(t.width>e&&this._free.push(new Z.Z(t.x+e,t.y,t.width-e,i)),t.height>i&&this._free.push(new Z.Z(t.x,t.y+i,t.width,t.height-i))):(t.width>e&&this._free.push(new Z.Z(t.x+e,t.y,t.width-e,t.height)),t.height>i&&this._free.push(new Z.Z(t.x,t.y+i,e,t.height-i))),new Z.Z(t.x,t.y,e,i))}release(e){for(let i=0;i<this._free.length;++i){const t=this._free[i];if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)t.width+=e.width;else if(t.x===e.x&&t.width===e.width&&t.y+t.height===e.y)t.height+=e.height;else if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)t.x=e.x,t.width+=e.width;else{if(e.x!==t.x||e.width!==t.width||e.y+e.height!==t.y)continue;t.y=e.y,t.height+=e.height}this._free.splice(i,1),this.release(e)}this._free.push(e)}}var u=f(67969),K=f(55086);class Q{constructor(e,i,t){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=e,this.height=i,this._glyphSource=t,this._binPack=new w(e-4,i-4),this._glyphData.push(new Uint8Array(e*i)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(e,i){const t=[],n=this._glyphSource,r=new Set;for(const s of i){const l=Math.floor(.00390625*s);r.add(l)}const a=[];return r.forEach(s=>{if(s<=256){const l=e+s;if(this._rangePromises.has(l))a.push(this._rangePromises.get(l));else{const h=n.getRange(e,s).then(()=>{this._rangePromises.delete(l)},()=>{this._rangePromises.delete(l)});this._rangePromises.set(l,h),a.push(h)}}}),Promise.all(a).then(()=>{let s=this._glyphIndex[e];s||(s={},this._glyphIndex[e]=s);for(const l of i){const h=s[l];if(h){t[l]={sdf:!0,rect:h.rect,metrics:h.metrics,page:h.page,code:l};continue}const m=n.getGlyph(e,l);if(!m||!m.metrics)continue;const _=m.metrics;let c;if(0===_.width)c=new Z.Z(0,0,0,0);else{const p=_.width+6,y=_.height+6;let x=p%4?4-p%4:4,g=y%4?4-y%4:4;1===x&&(x=5),1===g&&(g=5),c=this._binPack.allocate(p+x,y+g),c.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new w(this.width-4,this.height-4),c=this._binPack.allocate(p+x,y+g));const L=this._glyphData[this._currentPage],D=m.bitmap;let S,R;if(D)for(let T=0;T<y;T++){S=p*T,R=this.width*(c.y+T+1)+c.x;for(let P=0;P<p;P++)L[R+P+1]=D[S+P]}}s[l]={rect:c,metrics:_,tileIDs:null,page:this._currentPage},t[l]={sdf:!0,rect:c,metrics:_,page:this._currentPage,code:l},this._dirties[this._currentPage]=!0}return t})}removeGlyphs(e){for(const i in this._glyphIndex){const t=this._glyphIndex[i];if(!t)continue;let n;for(const r in t)if(n=t[r],n.tileIDs.delete(e),0===n.tileIDs.size){const o=this._glyphData[n.page],a=n.rect;let s,l;for(let h=0;h<a.height;h++)for(s=this.width*(a.y+h)+a.x,l=0;l<a.width;l++)o[s+l]=0;delete t[r],this._dirties[n.page]=!0}}}bind(e,i,t,n=0){this._textures[t]||(this._textures[t]=new K.x(e,{pixelFormat:u.VI.ALPHA,dataType:u.Br.UNSIGNED_BYTE,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));const r=this._textures[t];r.setSamplingMode(i),this._dirties[t]&&r.setData(this._glyphData[t]),e.bindTexture(r,n),this._dirties[t]=!1}dispose(){this._binPack=null;for(const e of this._textures)e&&e.dispose();this._textures.length=0}}var be=f(84792),le=f(24192);class ae{constructor(e){if(this._metrics=[],this._bitmaps=[],e)for(;e.next();)switch(e.tag()){case 1:{const i=e.getMessage();for(;i.next();)switch(i.tag()){case 3:{const t=i.getMessage();let n,r,o,a,s,l,h;for(;t.next();)switch(t.tag()){case 1:n=t.getUInt32();break;case 2:r=t.getBytes();break;case 3:o=t.getUInt32();break;case 4:a=t.getUInt32();break;case 5:s=t.getSInt32();break;case 6:l=t.getSInt32();break;case 7:h=t.getUInt32();break;default:t.skip()}t.release(),n&&(this._metrics[n]={width:o,height:a,left:s,top:l,advance:h},this._bitmaps[n]=r);break}default:i.skip()}i.release();break}default:e.skip()}}getMetrics(e){return this._metrics[e]}getBitmap(e){return this._bitmaps[e]}}class Pe{constructor(){this._ranges=[]}getRange(e){return this._ranges[e]}addRange(e,i){this._ranges[e]=i}}class se{constructor(e){this._glyphInfo={},this._baseURL=e}getRange(e,i){const t=this._getFontStack(e);if(t.getRange(i))return Promise.resolve();const n=256*i,r=n+255;if(this._baseURL){const o=this._baseURL.replace("{fontstack}",e).replace("{range}",n+"-"+r);return(0,be.default)(o,{responseType:"array-buffer"}).then(a=>{t.addRange(i,new ae(new le.Z(new Uint8Array(a.data),new DataView(a.data))))}).catch(()=>{t.addRange(i,new ae)})}return t.addRange(i,new ae),Promise.resolve()}getGlyph(e,i){const t=this._getFontStack(e);if(!t)return;const n=Math.floor(i/256);if(n>256)return;const r=t.getRange(n);return r?{metrics:r.getMetrics(i),bitmap:r.getBitmap(i)}:void 0}_getFontStack(e){let i=this._glyphInfo[e];return i||(i=this._glyphInfo[e]=new Pe),i}}var He=f(26996);class ve{constructor(e,i,t=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(e<=0||i<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=i,t>0&&(this._maxItemSize=t),this._binPack=new w(e-4,i-4)}dispose(){this._binPack=null,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new w(this._pageWidth-4,this._pageHeight-4);const i=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),n=new Uint32Array(i*t);this._mosaicsData[0]=n,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,i=!1){let t,n,r=this._mosaicRects[e];if(r)return r;if(!this._sprites||"loaded"!==this._sprites.loadStatus||(e&&e.startsWith("dasharray-")?([t,n]=this._rasterizeDash(e),i=!0):t=this._sprites.getSpriteInfo(e),!t||!t.width||!t.height||t.width<0||t.height<0))return null;const o=t.width,a=t.height,[s,l,h]=this._allocateImage(o,a);return s.width<=0?null:(this._copy(s,t,l,h,i,n),r={rect:s,width:o,height:a,sdf:t.sdf,simplePattern:!1,pixelRatio:t.pixelRatio,page:l},this._mosaicRects[e]=r,r)}getSpriteItems(e){const i={};for(const t of e)i[t.name]=this.getSpriteItem(t.name,t.repeat);return i}getMosaicItemPosition(e,i){const t=this.getSpriteItem(e,i),n=t&&t.rect;return n?(n.width=t.width,n.height=t.height,{tl:[n.x+2,n.y+2],br:[n.x+2+t.width,n.y+2+t.height],page:t.page}):null}bind(e,i,t=0,n=0){if(t>=this._size.length||t>=this._mosaicsData.length)return;this._textures[t]||(this._textures[t]=new K.x(e,{pixelFormat:u.VI.RGBA,dataType:u.Br.UNSIGNED_BYTE,wrapMode:u.e8.CLAMP_TO_EDGE,width:this._size[t][0],height:this._size[t][1]},new Uint8Array(this._mosaicsData[t].buffer)));const r=this._textures[t];r.setSamplingMode(i),this._dirties[t]&&r.setData(new Uint8Array(this._mosaicsData[t].buffer)),e.bindTexture(r,n),this._dirties[t]=!1}static _copyBits(e,i,t,n,r,o,a,s,l,h,m){let _=n*i+t,c=s*o+a;if(m){c-=o;for(let v=-1;v<=h;v++,_=((v+h)%h+n)*i+t,c+=o)for(let p=-1;p<=l;p++)r[c+p]=e[_+(p+l)%l]}else for(let v=0;v<h;v++){for(let p=0;p<l;p++)r[c+p]=e[_+p];_+=i,c+=o}}_copy(e,i,t,n,r,o){if(!this._sprites||"loaded"!==this._sprites.loadStatus||t>=this._mosaicsData.length)return;const a=new Uint32Array(o?o.buffer:this._sprites.image.buffer),s=this._mosaicsData[t];s&&a||console.error("Source or target images are uninitialized!"),ve._copyBits(a,o?i.width:this._sprites.width,i.x,i.y,s,n[0],e.x+2,e.y+2,i.width,i.height,r),this._dirties[t]=!0}_allocateImage(e,i){e+=2,i+=2;const t=Math.max(e,i);if(this._maxItemSize&&this._maxItemSize<t){const a=new Z.Z(0,0,e,i);return this._mosaicsData.push(new Uint32Array(e*i)),this._dirties.push(!0),this._size.push([e,i]),this._textures.push(void 0),[a,this._mosaicsData.length-1,[e,i]]}let n=e%4?4-e%4:4,r=i%4?4-i%4:4;1===n&&(n=5),1===r&&(r=5);const o=this._binPack.allocate(e+n,i+r);return o.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new w(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,i)):[o,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const t=e.match(/\[(.*?)\]/);if(!t)return null;const n=t[1].split(",").map(Number),r=e.slice(e.lastIndexOf("-")+1),[o,a,s]=(0,He.m)(n,r);return[{x:0,y:0,width:a,height:s,sdf:!0,pixelRatio:1},new Uint8Array(o.buffer)]}}var me=f(58098);class Ke{constructor(e,i,t){this._layer=e,this._styleRepository=i,this.devicePixelRatio=t,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}destroy(){this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._layer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}start(e){var i=this;return(0,W.Z)(function*(){i._spriteSourcePromise=i._layer.loadSpriteSource(i.devicePixelRatio,e),i._spriteSourcePromise.then(n=>{i._spriteMosaic=new ve(1024,1024,250),i._spriteMosaic.setSpriteSource(n)});const t=new se(i._layer.currentStyleInfo.glyphsUrl?(0,A.fl)(i._layer.currentStyleInfo.glyphsUrl,{...i._layer.customParameters,token:i._layer.apiKey}):null);i._glyphMosaic=new Q(1024,1024,t),i._broadcastPromise=(0,j.bA)("WorkerTileHandler",{client:i,schedule:e.schedule,signal:e.signal}).then(n=>{if(i._connection=n,i._layer&&!i._connection.closed){const r=n.broadcast("setStyle",i._layer.currentStyleInfo.style,e);Promise.all(r).catch(o=>(0,$.H9)(o))}})})()}updateStyle(e){var i=this;return(0,W.Z)(function*(){return yield i._broadcastPromise,i._broadcastPromise=Promise.all(i._connection.broadcast("updateStyle",e)),i._broadcastPromise})()}setSpriteSource(e){const i=new ve(1024,1024,250);return i.setSpriteSource(e),this._spriteMosaic=i,this._spriteSourcePromise=Promise.resolve(e),i}setStyle(e,i){var t=this;return(0,W.Z)(function*(){yield t._broadcastPromise,t._styleRepository=e,t._spriteSourcePromise=t._layer.loadSpriteSource(t.devicePixelRatio,null),t._spriteSourcePromise.then(r=>{t._spriteMosaic=new ve(1024,1024,250),t._spriteMosaic.setSpriteSource(r)});const n=new se(t._layer.currentStyleInfo.glyphsUrl?(0,A.fl)(t._layer.currentStyleInfo.glyphsUrl,{...t._layer.customParameters,token:t._layer.apiKey}):null);return t._glyphMosaic=new Q(1024,1024,n),t._broadcastPromise=Promise.all(t._connection.broadcast("setStyle",i)),t._broadcastPromise})()}fetchTileData(e,i){return this._getRefKeys(e,i).then(t=>{const n=this._layer.sourceNameToSource,r=[];for(const o in n)r.push(o);return this._getSourcesData(r,t,i)})}parseTileData(e,i){const t=e&&e.data;if(!t)return Promise.resolve(null);const{sourceName2DataAndRefKey:n,transferList:r}=t;return 0===Object.keys(n).length?Promise.resolve(null):this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:n,styleLayerUIDs:e.styleLayerUIDs},{...i,transferList:r}))}getSprites(e){var i=this;return(0,W.Z)(function*(){return yield i._spriteSourcePromise,i._spriteMosaic.getSpriteItems(e)})()}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}_getTilePayload(e,i,t){var n=this;return(0,W.Z)(function*(){const r=me.Z.pool.acquire(e.id),o=n._layer.sourceNameToSource[i],{level:a,row:s,col:l}=r;me.Z.pool.release(r);try{return{protobuff:yield o.requestTile(a,s,l,t),sourceName:i}}catch(h){if((0,$.D_)(h))throw h;return{protobuff:null,sourceName:i}}})()}_getRefKeys(e,i){const t=this._layer.sourceNameToSource,n=new Array;for(const r in t){const o=t[r].getRefKey(e,i);n.push(o)}return(0,$.as)(n)}_getSourcesData(e,i,t){const n=[];for(let r=0;r<i.length;r++)if(null==i[r].value||null==e[r])n.push(null);else{const o=this._getTilePayload(i[r].value,e[r],t);n.push(o)}return(0,$.as)(n).then(r=>{const o={},a=[];for(let s=0;s<r.length;s++)r[s].value&&r[s].value&&r[s].value.protobuff&&r[s].value.protobuff.byteLength>0&&(o[r[s].value.sourceName]={refKey:i[s].value.id,protobuff:r[s].value.protobuff},a.push(r[s].value.protobuff));return{sourceName2DataAndRefKey:o,transferList:a}})}}var je=f(54540),Je=f(51200),Me=f(47132),ye=f(76763),z=f(1268);function Ze(d,e,i,t,n,r){const{iconRotationAlignment:o,textRotationAlignment:a,iconTranslate:s,iconTranslateAnchor:l,textTranslate:h,textTranslateAnchor:m}=t;let _=0;for(const c of d.colliders){const[v,p]=0===c.partIndex?s:h,y=0===c.partIndex?l:m,x=c.minLod<=r&&r<=c.maxLod;_+=x?0:1,c.enabled=x,c.xScreen=c.xTile*n[0]+c.yTile*n[3]+n[6],c.yScreen=c.xTile*n[1]+c.yTile*n[4]+n[7],y===z.fD.MAP?(c.xScreen+=i*v-e*p,c.yScreen+=e*v+i*p):(c.xScreen+=v,c.yScreen+=p),z.aF.VIEWPORT===(0===c.partIndex?o:a)?(c.dxScreen=c.dxPixels,c.dyScreen=c.dyPixels):(c.dxScreen=i*(c.dxPixels+c.width/2)-e*(c.dyPixels+c.height/2)-c.width/2,c.dyScreen=e*(c.dxPixels+c.width/2)+i*(c.dyPixels+c.height/2)-c.height/2)}d.colliders.length>0&&_===d.colliders.length&&(d.unique.show=!1)}class Xe{constructor(e,i,t,n,r,o){this._symbols=e,this._styleRepository=n,this._zoom=r,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new ye.HX(i,t,Me.PF),this._si=Math.sin(Math.PI*o/180),this._co=Math.cos(Math.PI*o/180);for(const a of e)for(const s of a.symbols)this._allNeededMatrices.has(s.tile)||this._allNeededMatrices.set(s.tile,(0,B.a)(s.tile.transforms.tileUnitsToPixels))}work(e){const i=this._gridIndex;function t(r){const o=r.xScreen+r.dxScreen,a=r.yScreen+r.dyScreen,s=o+r.width,l=a+r.height,[h,m,_,c]=i.getCellSpan(o,a,s,l);for(let v=m;v<=c;v++)for(let p=h;p<=_;p++){const y=i.cells[v][p];for(const x of y){const g=x.xScreen+x.dxScreen,L=x.yScreen+x.dyScreen,D=g+x.width,S=L+x.height;if(!(s<g||o>D||l<L||a>S))return!0}}return!1}const n=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const r=this._symbols[this._currentLayerCursor],o=this._getProperties(r.styleLayerUID);for(;this._currentSymbolCursor<r.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-n>e)return!1;const a=r.symbols[this._currentSymbolCursor];if(!a.unique.show)continue;Ze(a,this._si,this._co,o,this._allNeededMatrices.get(a.tile),this._zoom);const s=a.unique;if(!s.show)continue;const{iconAllowOverlap:l,iconIgnorePlacement:h,textAllowOverlap:m,textIgnorePlacement:_}=o;for(const c of a.colliders){if(!c.enabled)continue;const v=s.parts[c.partIndex];!v.show||!(c.partIndex?m:l)&&t(c)&&(c.hard?s.show=!1:v.show=!1)}if(s.show)for(const c of a.colliders){if(!c.enabled||(c.partIndex?_:h)||!s.parts[c.partIndex].show)continue;const v=c.xScreen+c.dxScreen,p=c.yScreen+c.dyScreen,y=v+c.width,x=p+c.height,[g,L,D,S]=this._gridIndex.getCellSpan(v,p,y,x);for(let R=L;R<=S;R++)for(let T=g;T<=D;T++)this._gridIndex.cells[R][T].push(c)}}}return!0}_getProperties(e){const i=this._styleProps.get(e);if(i)return i;const t=this._zoom,n=this._styleRepository.getStyleLayerByUID(e),r=n.getLayoutValue("symbol-placement",t)!==z.R.POINT;let o=n.getLayoutValue("icon-rotation-alignment",t);o===z.aF.AUTO&&(o=r?z.aF.MAP:z.aF.VIEWPORT);let a=n.getLayoutValue("text-rotation-alignment",t);a===z.aF.AUTO&&(a=r?z.aF.MAP:z.aF.VIEWPORT);const s=n.getPaintValue("icon-translate",t),l=n.getPaintValue("icon-translate-anchor",t),h=n.getPaintValue("text-translate",t),m=n.getPaintValue("text-translate-anchor",t),_={iconAllowOverlap:n.getLayoutValue("icon-allow-overlap",t),iconIgnorePlacement:n.getLayoutValue("icon-ignore-placement",t),textAllowOverlap:n.getLayoutValue("text-allow-overlap",t),textIgnorePlacement:n.getLayoutValue("text-ignore-placement",t),iconRotationAlignment:o,textRotationAlignment:a,iconTranslateAnchor:l,iconTranslate:s,textTranslateAnchor:m,textTranslate:h};return this._styleProps.set(e,_),_}}function Ye(d,e){if(d.priority-e.priority)return d.priority-e.priority;const i=d.tile.key,t=e.tile.key;return i.world-t.world?i.world-t.world:i.level-t.level?i.level-t.level:i.row-t.row?i.row-t.row:i.col-t.col?i.col-t.col:d.xTile-e.xTile?d.xTile-e.xTile:d.yTile-e.yTile}class $e{constructor(e,i,t,n,r,o){this._visibleTiles=e,this._symbolRepository=i,this._createCollisionJob=t,this._assignTileSymbolsOpacity=n,this._symbolLayerSorter=r,this._isLayerVisible=o,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}get running(){return this._running}setScreenSize(e,i){this._screenWidth===e&&this._screenHeight===i||this.restart(),this._screenWidth=e,this._screenHeight=i}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(e){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const i=performance.now();if(!this._selectionJob.work(e)||(this._selectionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-i)))))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const i=performance.now();if(!this._collisionJob.work(e)||(this._collisionJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-i)))))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const i=performance.now();if(!this._opacityJob.work(e)||(this._opacityJobCompleted=!0,0===(e=Math.max(0,e-(performance.now()-i)))))return!1}return this._running=!1,!0}_createSelectionJob(){const e=this._symbolRepository.uniqueSymbols;for(let s=0;s<e.length;s++){const l=e[s];for(let h=0;h<l.uniqueSymbols.length;h++){const m=l.uniqueSymbols[h];for(const _ of m.tileSymbols)_.selectedForRendering=!1}}const i=[];let t=0,n=0;const r=this._isLayerVisible,a=this._symbolLayerSorter;return{work:function o(s){let l;const h=performance.now();for(;n<e.length;n++,t=0){const m=e[n],_=m.styleLayerUID;if(!r(_)){i[n]||(i[n]={styleLayerUID:_,symbols:[]});continue}i[n]=i[n]||{styleLayerUID:_,symbols:[]};const c=i[n];for(;t<m.uniqueSymbols.length;t++){if(l=m.uniqueSymbols[t],t%100==99&&performance.now()-h>s)return!1;let v=null,p=!1,y=!1;for(const x of l.tileSymbols)if(!y||!p){const g=x.tile;(!v||g.isCoverage||g.neededForCoverage&&!p)&&(v=x,(g.neededForCoverage||g.isCoverage)&&(y=!0),g.isCoverage&&(p=!0))}if(v.selectedForRendering=!0,y){c.symbols.push(v),l.show=!0;for(const x of l.parts)x.show=!0}else l.show=!1}}for(const m of i)m.symbols.sort(Ye);return!0},get sortedSymbols(){return i.sort(a)}}}_createOpacityJob(){const e=this._assignTileSymbolsOpacity,i=this._visibleTiles;let t=0;function n(r,o){const a=r.symbols;for(const[s,l]of a)Qe(l,o);e(r,o);for(const s of r.childrenTiles)n(s,o)}return{work(r){const o=performance.now();for(;t<i.length;t++){if(performance.now()-o>r)return!1;const a=i[t];(0,b.pC)(a.parentTile)||n(a,performance.now())}return!0}}}}function Qe(d,e){for(const i of d){const t=i.unique;for(const n of t.parts)n.startOpacity+=(e-n.startTime)/Me.nN*(n.targetOpacity>.5?1:-1),n.startOpacity=Math.min(Math.max(n.startOpacity,0),1),n.startTime=e,n.targetOpacity=t.show&&n.show?1:0}}class it{constructor(e,i,t){this.tileCoordRange=e,this._visibleTiles=i,this._createUnique=t,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return(0,b.Wi)(this._uniqueSymbolLayerArray)&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(e,i){this._uniqueSymbolLayerArray=null;let t=this._tiles.get(e.id);t||(t={symbols:new Map},this._tiles.set(e.id,t));const n=new Map;if(i)for(const a of i)t.symbols.has(a)&&(n.set(a,t.symbols.get(a)),t.symbols.delete(a));else for(const[a,s]of e.layerData)t.symbols.has(a)&&(n.set(a,t.symbols.get(a)),t.symbols.delete(a));this._removeSymbols(n);const r=e.symbols,o=new Map;for(const[a,s]of r){let l=s.length;if(l>=32){let h=this.tileCoordRange;do{h/=2,l/=4}while(l>8&&h>64);const m=new ye.HX(this.tileCoordRange,this.tileCoordRange,h);o.set(a,{flat:s,index:m}),t.symbols.set(a,{flat:s,index:m});for(const _ of s)m.getCell(_.xTile,_.yTile).push(_)}else o.set(a,{flat:s}),t.symbols.set(a,{flat:s})}this._addSymbols(e.key,r)}deleteStyleLayers(e){this._uniqueSymbolLayerArray=null;for(const[i,t]of this._tiles){const n=new Map;for(const r of e)t.symbols.has(r)&&(n.set(r,t.symbols.get(r)),t.symbols.delete(r));this._removeSymbols(n),0===t.symbols.size&&this._tiles.delete(i)}}removeTile(e){this._uniqueSymbolLayerArray=null;const i=this._tiles.get(e.id);if(!i)return;const t=new Map;for(const[n,r]of e.symbols)i.symbols.has(n)&&(t.set(n,i.symbols.get(n)),i.symbols.delete(n));this._removeSymbols(t),0===i.symbols.size&&this._tiles.delete(e.id)}_removeSymbols(e){for(const[i,{flat:t}]of e)for(const n of t){const r=n.unique,o=r.tileSymbols,a=o.length-1;for(let s=0;s<a;s++)if(o[s]===n){o[s]=o[a];break}if(o.length=a,0===a){const s=this._uniqueSymbolsReferences.get(i);s.delete(r),0===s.size&&this._uniqueSymbolsReferences.delete(i)}n.unique=null}}_addSymbols(e,i){if(0===i.size)return;const t=this._visibleTiles;for(const n of t)n.parentTile||n.key.world!==e.world||n.key.level===e.level&&!n.key.equals(e)||this._matchSymbols(n,e,i);for(const[n,r]of i)for(const o of r)if((0,b.Wi)(o.unique)){const a=this._createUnique();o.unique=a,a.tileSymbols.push(o);let s=this._uniqueSymbolsReferences.get(n);s||(s=new Set,this._uniqueSymbolsReferences.set(n,s)),s.add(a)}}_matchSymbols(e,i,t){if(e.key.level>i.level){const r=e.key.level-i.level;if(e.key.row>>r!==i.row||e.key.col>>r!==i.col)return}if(i.level>e.key.level){const r=i.level-e.key.level;if(i.row>>r!==e.key.row||i.col>>r!==e.key.col)return}if(i.equals(e.key)){for(const r of e.childrenTiles)this._matchSymbols(r,i,t);return}const n=new Map;for(const[r,o]of t){const a=[];for(const m of o){const _=(0,ye.co)(this.tileCoordRange,m.xTile,i.level,i.col,e.key.level,e.key.col),c=(0,ye.co)(this.tileCoordRange,m.yTile,i.level,i.row,e.key.level,e.key.row);_>=0&&_<this.tileCoordRange&&c>=0&&c<this.tileCoordRange&&a.push({symbol:m,xTransformed:_,yTransformed:c})}const s=[],l=e.key.level<i.level?1:1<<e.key.level-i.level,h=this._tiles.get(e.id).symbols.get(r);if(h){const m=h.flat;for(const _ of a){let c,v=!1;const p=_.xTransformed,y=_.yTransformed;c=(0,b.pC)(h.index)?h.index.getCell(p,y):m;const x=_.symbol,g=x.hash;for(const L of c)if(g===L.hash&&Math.abs(p-L.xTile)<=l&&Math.abs(y-L.yTile)<=l){const D=L.unique;x.unique=D,D.tileSymbols.push(x),v=!0;break}v||s.push(x)}}s.length>0&&n.set(r,s)}for(const r of e.childrenTiles)this._matchSymbols(r,i,n)}_createUniqueSymbolLayerArray(){const e=this._uniqueSymbolsReferences,i=new Array(e.size);let t,n=0;for(const[r,o]of e){const a=new Array(o.size);t=0;for(const s of o)a[t++]=s;i[n]={styleLayerUID:r,uniqueSymbols:a},n++}return i}}var rt=f(2584),ot=f(9598);class at extends ot.Z{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const i=me.Z.pool.acquire(e),t=0===i.level?null:me.Z.getId(i.level-1,i.row>>1,i.col>>1,i.world);return me.Z.pool.release(i),t}getTileCoverage(e,i,t){const n=super.getTileCoverage(e,i,t);if(!n)return n;const r=1<<n.lodInfo.level;return n.spans=n.spans.filter(o=>o.row>=0&&o.row<r),n}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const i=this._fullCacheLodInfos;if(e>i[0].scale)return i[0].level;let t,n;for(let r=0;r<i.length-1;r++)if(n=i[r+1],e>n.scale)return t=i[r],t.level+(t.scale-e)/(t.scale-n.scale);return i[i.length-1].level}}_initializeFullCacheLODs(e){let i;i=0===e[0].level?e.map(t=>({level:t.level,resolution:t.resolution,scale:t.scale})):rt.Z.create({size:this.tileInfo.size[0],spatialReference:this.tileInfo.spatialReference}).lods.map(r=>({level:r.level,resolution:r.resolution,scale:r.scale}));for(let t=0;t<i.length;t++)this._levelByScale[i[t].scale]=i[t].level;this._fullCacheLodInfos=i}}class Te extends Ke{constructor(e,i,t,n,r){super(e,i,t),this._memCache=n,this._loader=r,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new at(e.tileInfo,e.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach(e=>e.abort()),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}getVectorTile(e,i,t,n){var r=this;return(0,W.Z)(function*(){const o=new me.Z(e,i,t,0);let a=r._memCache.get(o.id);if((0,b.pC)(a))return a.retain(),a;const s=yield r._getVectorTileData(o);if((0,$.k_)(n),!r._layer)return null;if(a=r._memCache.get(o.id),(0,b.pC)(a))return a.retain(),a;const l=r._layer.tileInfo.getTileBounds((0,U.Ue)(),o),h=r._tileInfoView.getTileResolution(e);return a=new je.i(o,h,l[0],l[3],512,512,r._styleRepository,r._memCache),(0,b.pC)(s)?(a.setData(s),a.retain(),r._memCache.put(o.id,a,a.memoryUsage*a.referenced,E.an)):a.setData(null),a.neededForCoverage=!0,a.transforms.tileUnitsToPixels=(0,B.f)(1/8,0,0,0,1/8,0,0,0,1),function nt(d,e){const i=[],t=new it(4096,i,()=>{const r=new Je.J;return r.show=!1,r.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),r.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),r}),n=new $e(i,t,(r,o,a)=>new Xe(r,o,a,d.styleRepository,d.key.level,0),(r,o)=>{(0,ye.C$)(r,o,!1)},()=>0,r=>{const o=e.getStyleLayerByUID(r).getLayoutProperty("visibility");return!o||o.getValue()!==z.EE.NONE});i.push(d),t.add(d),n.setScreenSize(512,512),n.continue(1/0)}(a,r._styleRepository),a})()}_getVectorTileData(e){const i=e.id;if(this._ongoingTileRequests.has(i))return this._ongoingTileRequests.get(i);const t=new AbortController,r=this._getParsedVectorTileData(e,{signal:t.signal}).then(o=>(this._ongoingTileRequests.delete(i),this._ongoingRequestToController.delete(i),o)).catch(()=>(this._ongoingTileRequests.delete(i),this._ongoingRequestToController.delete(i),null));return this._ongoingTileRequests.set(i,r),this._ongoingRequestToController.set(i,t),r}_getParsedVectorTileData(e,i){return this.fetchTileData(e,i).then(t=>this.parseTileData({key:e,data:t},i))}request(e,i){return this._loader.request(e,"binary",i)}}var Ie=f(21286),st=f(67709),te=f(39351),ce=f(39406),xe=f(5254);class we{constructor(){this.name=this.constructor.name||"UnnamedBrush",this.brushEffect=null}prepareState(e,i){}draw(e,i,t){}drawMany(e,i,t){for(const n of i)n.visible&&this.draw(e,n,t)}}var lt=f(83994),ct=f(49353);const Ce=1/65536;var De=f(9545),Re=f(43289);const pt={vtlBackground:class ut extends we{constructor(){super(...arguments),this._color=(0,st.f)(1,0,0,1),this._patternMatrix=(0,B.c)(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao&&(this._vao.dispose(),this._vao=null)}drawMany(e,i){const{context:t,painter:n,styleLayerUID:r,requestRender:o,allowDelayedRender:a}=e;this._loadWGLResources(e);const s=e.displayLevel,l=e.styleLayer,h=l.backgroundMaterial,m=n.vectorTilesMaterialManager,_=l.getPaintValue("background-color",s),c=l.getPaintValue("background-opacity",s),v=l.getPaintValue("background-pattern",s),p=void 0!==v,y=_[3]*c,x=1|window.devicePixelRatio,g=e.spriteMosaic;let L,D;const S=x>te.a?2:1,R=e.drawPhase===ce.jx.HITTEST,T=this._programOptions;T.id=R,T.pattern=p;const P=m.getMaterialProgram(t,h,T);if(a&&(0,b.pC)(o)&&!P.isCompiled)o();else{if(t.bindVAO(this._vao),t.useProgram(P),p){const I=g.getMosaicItemPosition(v,!0);if((0,b.pC)(I)){const{tl:O,br:C,page:H}=I;L=C[0]-O[0],D=C[1]-O[1];const k=g.getPageSize(H);(0,b.pC)(k)&&(g.bind(t,u.cw.LINEAR,H,te.V4),P.setUniform4f("u_tlbr",O[0],O[1],C[0],C[1]),P.setUniform2fv("u_mosaicSize",k),P.setUniform1i("u_texture",te.V4))}P.setUniform1f("u_opacity",c)}else this._color[0]=y*_[0],this._color[1]=y*_[1],this._color[2]=y*_[2],this._color[3]=y,P.setUniform4fv("u_color",this._color);if(P.setUniform1f("u_depth",l.z||0),R){const I=(0,xe.Au)(r+1);P.setUniform4fv("u_id",I)}for(const I of i){if(P.setUniform1f("u_coord_range",I.rangeX),P.setUniformMatrix3fv("u_dvsMat3",I.transforms.dvs),p){const O=Math.max(2**(Math.round(s)-I.key.level),1),C=S*I.width*O,H=C/(0,Ie.fp)(L),k=C/(0,Ie.fp)(D);this._patternMatrix[0]=H,this._patternMatrix[4]=k,P.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}t.setStencilFunction(u.wb.EQUAL,0,255),t.drawArrays(u.MX.TRIANGLE_STRIP,0,4)}}}_loadWGLResources(e){if(this._vao)return;const{context:i,styleLayer:t}=e,n=t.backgroundMaterial,r=new Int8Array([0,0,1,0,0,1,1,1]),o=lt.f.createVertex(i,u.l1.STATIC_DRAW,r),a=new ct.U(i,n.getAttributeLocations(),n.getLayoutInfo(),{geometry:o});this._vao=a}},vtlFill:class ht extends we{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(e,i){const{displayLevel:t,drawPhase:n,renderPass:r,spriteMosaic:o,styleLayerUID:a}=e;let s=!1;for(const S of i)if(S.layerData.has(a)){const R=S.layerData.get(a);if(R.fillIndexCount>0||R.outlineIndexCount>0){s=!0;break}}if(!s)return;const l=e.styleLayer,h=l.getPaintProperty("fill-pattern"),m=void 0!==h,_=m&&h.isDataDriven;let c;if(m&&!_){const S=h.getValue(t);c=o.getMosaicItemPosition(S,!0)}const v=!m&&l.getPaintValue("fill-antialias",t);let x,p=!0,y=1;if(!m){const S=l.getPaintProperty("fill-color"),R=l.getPaintProperty("fill-opacity");if(!S?.isDataDriven&&!R?.isDataDriven){const T=l.getPaintValue("fill-color",t);y=l.getPaintValue("fill-opacity",t)*T[3],y>=1&&(p=!1)}}if(p&&"opaque"===r)return;n===ce.jx.HITTEST&&(x=(0,xe.Au)(a+1));const g=l.getPaintValue("fill-translate",t),L=l.getPaintValue("fill-translate-anchor",t);(p||"translucent"!==r)&&this._drawFill(e,a,l,i,g,L,m,c,_,x),v&&"opaque"!==r&&!(!l.hasDataDrivenOutlineColor&&l.outlineUsesFillColor&&y<1)&&this._drawOutline(e,a,l,i,g,L,x)}_drawFill(e,i,t,n,r,o,a,s,l,h){if(a&&!l&&(0,b.Wi)(s))return;const{context:m,displayLevel:_,state:c,drawPhase:v,painter:p,pixelRatio:y,spriteMosaic:x,requestRender:g,allowDelayedRender:L}=e,D=t.fillMaterial,S=p.vectorTilesMaterialManager,R=y>te.a?2:1,T=v===ce.jx.HITTEST,P=this._fillProgramOptions;P.id=T,P.pattern=a;const I=S.getMaterialProgram(m,D,P);if(L&&(0,b.pC)(g)&&!I.isCompiled)return void g();if(m.useProgram(I),(0,b.pC)(s)){const{page:C}=s,H=x.getPageSize(C);(0,b.pC)(H)&&(x.bind(m,u.cw.LINEAR,C,te.V4),I.setUniform2fv("u_mosaicSize",H),I.setUniform1i("u_texture",te.V4))}I.setUniformMatrix3fv("u_displayMat3",o===z.fD.VIEWPORT?c.displayMat3:c.displayViewMat3),I.setUniform2fv("u_fillTranslation",r),I.setUniform1f("u_depth",t.z+Ce),T&&I.setUniform4fv("u_id",h);let O=-1;for(const C of n){if(!C.layerData.has(i))continue;C.key.level!==O&&(O=C.key.level,D.setDataUniforms(I,_,t,O,x));const H=C.layerData.get(i);if(!H.fillIndexCount)continue;H.prepareForRendering(m);const k=H.fillVertexArrayObject;if(!(0,b.Wi)(k)){if(m.bindVAO(k),I.setUniformMatrix3fv("u_dvsMat3",C.transforms.dvs),m.setStencilFunction(u.wb.EQUAL,C.stencilRef,255),a){const ie=Math.max(2**(Math.round(_)-C.key.level),1);I.setUniform1f("u_patternFactor",C.rangeX/(R*C.width*ie))}if(l){const ie=H.patternMap;if(!ie)continue;for(const[q,fe]of ie){const _e=x.getPageSize(q);(0,b.pC)(_e)&&(x.bind(m,u.cw.LINEAR,q,te.V4),I.setUniform2fv("u_mosaicSize",_e),I.setUniform1i("u_texture",te.V4),m.drawElements(u.MX.TRIANGLES,fe[1],u.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*fe[0]))}}else m.drawElements(u.MX.TRIANGLES,H.fillIndexCount,u.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*H.fillIndexStart);C.triangleCount+=H.fillIndexCount/3}}}_drawOutline(e,i,t,n,r,o,a){const{context:s,displayLevel:l,state:h,drawPhase:m,painter:_,pixelRatio:c,spriteMosaic:v,requestRender:p,allowDelayedRender:y}=e,x=t.outlineMaterial,g=_.vectorTilesMaterialManager,L=.75/c,D=m===ce.jx.HITTEST,S=this._outlineProgramOptions;S.id=D;const R=g.getMaterialProgram(s,x,S);if(y&&(0,b.pC)(p)&&!R.isCompiled)return void p();s.useProgram(R),R.setUniformMatrix3fv("u_displayMat3",o===z.fD.VIEWPORT?h.displayMat3:h.displayViewMat3),R.setUniform2fv("u_fillTranslation",r),R.setUniform1f("u_depth",t.z+Ce),R.setUniform1f("u_outline_width",L),D&&R.setUniform4fv("u_id",a);let T=-1;for(const P of n){if(!P.layerData.has(i))continue;P.key.level!==T&&(T=P.key.level,x.setDataUniforms(R,l,t,T,v));const I=P.layerData.get(i);if(I.prepareForRendering(s),!I.outlineIndexCount)continue;const O=I.outlineVertexArrayObject;(0,b.Wi)(O)||(s.bindVAO(O),R.setUniformMatrix3fv("u_dvsMat3",P.transforms.dvs),s.setStencilFunction(u.wb.EQUAL,P.stencilRef,255),s.drawElements(u.MX.TRIANGLES,I.outlineIndexCount,u.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*I.outlineIndexStart),P.triangleCount+=I.outlineIndexCount/3)}}},vtlLine:class ft extends we{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(e,i){const{context:t,displayLevel:n,state:r,drawPhase:o,painter:a,pixelRatio:s,spriteMosaic:l,styleLayerUID:h,requestRender:m,allowDelayedRender:_}=e;if(!i.some(k=>k.layerData.get(h)?.lineIndexCount??!1))return;const c=e.styleLayer,v=c.lineMaterial,p=a.vectorTilesMaterialManager,y=c.getPaintValue("line-translate",n),x=c.getPaintValue("line-translate-anchor",n),g=c.getPaintProperty("line-pattern"),L=void 0!==g,D=L&&g.isDataDriven;let S,R;if(L&&!D){const k=g.getValue(n);S=l.getMosaicItemPosition(k)}let T=!1;if(!L){const k=c.getPaintProperty("line-dasharray");if(R=void 0!==k,T=R&&k.isDataDriven,R&&!T){const ie=k.getValue(n),q=c.getDashKey(ie,c.getLayoutValue("line-cap",n));S=l.getMosaicItemPosition(q)}}const P=1/s,I=o===ce.jx.HITTEST,O=this._programOptions;O.id=I,O.pattern=L,O.sdf=R;const C=p.getMaterialProgram(t,v,O);if(_&&(0,b.pC)(m)&&!C.isCompiled)return void m();if(t.useProgram(C),C.setUniformMatrix3fv("u_displayViewMat3",r.displayViewMat3),C.setUniformMatrix3fv("u_displayMat3",x===z.fD.VIEWPORT?r.displayMat3:r.displayViewMat3),C.setUniform2fv("u_lineTranslation",y),C.setUniform1f("u_depth",c.z),C.setUniform1f("u_antialiasing",P),I){const k=(0,xe.Au)(h+1);C.setUniform4fv("u_id",k)}if(S&&(0,b.pC)(S)){const{page:k}=S,ie=l.getPageSize(k);(0,b.pC)(ie)&&(l.bind(t,u.cw.LINEAR,k,te.V4),C.setUniform2fv("u_mosaicSize",ie),C.setUniform1i("u_texture",te.V4))}let H=-1;for(const k of i){if(!k.layerData.has(h))continue;k.key.level!==H&&(H=k.key.level,v.setDataUniforms(C,n,c,H,l)),C.setUniform1f("u_zoomFactor",2**(n-H)/s);const q=k.layerData.get(h);if(!q.lineIndexCount)continue;q.prepareForRendering(t);const fe=q.lineVertexArrayObject;if(!(0,b.Wi)(fe)){if(t.bindVAO(fe),C.setUniformMatrix3fv("u_dvsMat3",k.transforms.dvs),t.setStencilFunction(u.wb.EQUAL,k.stencilRef,255),D||T){const _e=q.patternMap;if(!_e)continue;for(const[Se,Y]of _e){const ge=l.getPageSize(Se);(0,b.pC)(ge)&&(l.bind(t,u.cw.LINEAR,Se,te.V4),C.setUniform2fv("u_mosaicSize",ge),C.setUniform1i("u_texture",te.V4),t.drawElements(u.MX.TRIANGLES,Y[1],u.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*Y[0]))}}else t.drawElements(u.MX.TRIANGLES,q.lineIndexCount,u.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*q.lineIndexStart);k.triangleCount+=q.lineIndexCount/3}}}},vtlCircle:class dt extends we{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(e,i){const{context:t,displayLevel:n,requiredLevel:r,state:o,drawPhase:a,painter:s,spriteMosaic:l,styleLayerUID:h,requestRender:m,allowDelayedRender:_}=e;if(!i.some(T=>T.layerData.get(h)?.circleIndexCount??!1))return;const c=e.styleLayer,v=c.circleMaterial,p=s.vectorTilesMaterialManager,x=c.getPaintValue("circle-translate",n),g=c.getPaintValue("circle-translate-anchor",n),L=a===ce.jx.HITTEST,D=this._programOptions;D.id=L;const S=p.getMaterialProgram(t,v,D);if(_&&(0,b.pC)(m)&&!S.isCompiled)return void m();t.useProgram(S),S.setUniformMatrix3fv("u_displayMat3",g===z.fD.VIEWPORT?o.displayMat3:o.displayViewMat3),S.setUniform2fv("u_circleTranslation",x),S.setUniform1f("u_depth",c.z),S.setUniform1f("u_antialiasingWidth",1.2);let R=-1;if(L){const T=(0,xe.Au)(h+1);S.setUniform4fv("u_id",T)}for(const T of i){if(!T.layerData.has(h))continue;T.key.level!==R&&(R=T.key.level,v.setDataUniforms(S,n,c,R,l));const P=T.layerData.get(h);if(!P.circleIndexCount)continue;P.prepareForRendering(t);const I=P.circleVertexArrayObject;(0,b.Wi)(I)||(t.bindVAO(I),S.setUniformMatrix3fv("u_dvsMat3",T.transforms.dvs),r!==T.key.level?t.setStencilFunction(u.wb.EQUAL,T.stencilRef,255):t.setStencilFunction(u.wb.GREATER,255,255),t.drawElements(u.MX.TRIANGLES,P.circleIndexCount,u.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*P.circleIndexStart),T.triangleCount+=P.circleIndexCount/3)}}},vtlSymbol:class mt extends we{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=(0,De.c)()}dispose(){}drawMany(e,i){const{drawPhase:t,styleLayerUID:n}=e,r=e.styleLayer;let o;t===ce.jx.HITTEST&&(o=(0,xe.Au)(n+1)),this._drawIcons(e,r,i,o),this._drawText(e,r,i,o)}_drawIcons(e,i,t,n){const{context:r,displayLevel:o,drawPhase:a,painter:s,spriteMosaic:l,state:h,styleLayerUID:m,requestRender:_,allowDelayedRender:c}=e,v=i.iconMaterial,p=s.vectorTilesMaterialManager;let y,x=!1;for(const H of t)if(H.layerData.has(m)&&(y=H.layerData.get(m),y.iconPerPageElementsMap.size>0)){x=!0;break}if(!x)return;const g=i.getPaintValue("icon-translate",o),L=i.getPaintValue("icon-translate-anchor",o);let D=i.getLayoutValue("icon-rotation-alignment",o);D===z.aF.AUTO&&(D=i.getLayoutValue("symbol-placement",o)===z.R.POINT?z.aF.VIEWPORT:z.aF.MAP);const S=D===z.aF.MAP,R=i.getLayoutValue("icon-keep-upright",o)&&S,T=y.isIconSDF,P=a===ce.jx.HITTEST,I=this._iconProgramOptions;I.id=P,I.sdf=T;const O=p.getMaterialProgram(r,v,I);if(c&&(0,b.pC)(_)&&!O.isCompiled)return void _();r.useProgram(O),O.setUniformMatrix3fv("u_displayViewMat3",D===z.aF.MAP?h.displayViewMat3:h.displayMat3),O.setUniformMatrix3fv("u_displayMat3",L===z.fD.VIEWPORT?h.displayMat3:h.displayViewMat3),O.setUniform2fv("u_iconTranslation",g),O.setUniform1f("u_depth",i.z),O.setUniform1f("u_mapRotation",(0,Re.s5)(h.rotation)),O.setUniform1f("u_keepUpright",R?1:0),O.setUniform1f("u_level",10*o),O.setUniform1i("u_texture",te.V4),O.setUniform1f("u_fadeDuration",Me.nN/1e3),P&&O.setUniform4fv("u_id",n);let C=-1;for(const H of t){if(!H.layerData.has(m)||(H.key.level!==C&&(C=H.key.level,v.setDataUniforms(O,o,i,C,l)),y=H.layerData.get(m),0===y.iconPerPageElementsMap.size))continue;y.prepareForRendering(r),y.updateOpacityInfo();const k=y.iconVertexArrayObject;if(!(0,b.Wi)(k)){r.bindVAO(k),O.setUniformMatrix3fv("u_dvsMat3",H.transforms.dvs),O.setUniform1f("u_time",(performance.now()-y.lastOpacityUpdate)/1e3);for(const[ie,q]of y.iconPerPageElementsMap)this._renderIconRange(e,O,q,ie,H)}}}_renderIconRange(e,i,t,n,r){const{context:o,spriteMosaic:a}=e;this._spritesTextureSize[0]=a.getWidth(n)/4,this._spritesTextureSize[1]=a.getHeight(n)/4,i.setUniform2fv("u_mosaicSize",this._spritesTextureSize),a.bind(o,u.cw.LINEAR,n,te.V4),o.setStencilTestEnabled(!0),o.setStencilFunction(u.wb.GREATER,255,255),o.setStencilWriteMask(0),o.drawElements(u.MX.TRIANGLES,t[1],u.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),r.triangleCount+=t[1]/3}_drawText(e,i,t,n){const{context:r,displayLevel:o,drawPhase:a,glyphMosaic:s,painter:l,pixelRatio:h,spriteMosaic:m,state:_,styleLayerUID:c,requestRender:v,allowDelayedRender:p}=e,y=i.textMaterial,x=l.vectorTilesMaterialManager;let g,L=!1;for(const ue of t)if(ue.layerData.has(c)&&(g=ue.layerData.get(c),g.glyphPerPageElementsMap.size>0)){L=!0;break}if(!L)return;const D=i.getPaintProperty("text-opacity");if(D&&!D.isDataDriven&&0===D.getValue(o))return;const S=i.getPaintProperty("text-color"),R=!S||S.isDataDriven||S.getValue(o)[3]>0,T=i.getPaintProperty("text-halo-width"),P=i.getPaintProperty("text-halo-color"),I=(!T||T.isDataDriven||T.getValue(o)>0)&&(!P||P.isDataDriven||P.getValue(o)[3]>0);if(!R&&!I)return;let C=i.getLayoutValue("text-rotation-alignment",o);C===z.aF.AUTO&&(C=i.getLayoutValue("symbol-placement",o)===z.R.POINT?z.aF.VIEWPORT:z.aF.MAP);const H=C===z.aF.MAP,k=i.getLayoutValue("text-keep-upright",o)&&H,ie=a===ce.jx.HITTEST,q=.8*3/h;this._glyphTextureSize||(this._glyphTextureSize=(0,De.f)(s.width/4,s.height/4));const fe=i.getPaintValue("text-translate",o),_e=i.getPaintValue("text-translate-anchor",o),Se=this._sdfProgramOptions;Se.id=ie;const Y=x.getMaterialProgram(r,y,Se);if(p&&(0,b.pC)(v)&&!Y.isCompiled)return void v();r.useProgram(Y),Y.setUniformMatrix3fv("u_displayViewMat3",C===z.aF.MAP?_.displayViewMat3:_.displayMat3),Y.setUniformMatrix3fv("u_displayMat3",_e===z.fD.VIEWPORT?_.displayMat3:_.displayViewMat3),Y.setUniform2fv("u_textTranslation",fe),Y.setUniform1f("u_depth",i.z+152587890625e-16),Y.setUniform2fv("u_mosaicSize",this._glyphTextureSize),Y.setUniform1f("u_mapRotation",(0,Re.s5)(_.rotation)),Y.setUniform1f("u_keepUpright",k?1:0),Y.setUniform1f("u_level",10*o),Y.setUniform1i("u_texture",te.CU),Y.setUniform1f("u_antialiasingWidth",q),Y.setUniform1f("u_fadeDuration",Me.nN/1e3),ie&&Y.setUniform4fv("u_id",n);let ge=-1;for(const ue of t){if(!ue.layerData.has(c)||(ue.key.level!==ge&&(ge=ue.key.level,y.setDataUniforms(Y,o,i,ge,m)),g=ue.layerData.get(c),0===g.glyphPerPageElementsMap.size))continue;g.prepareForRendering(r),g.updateOpacityInfo();const Be=g.textVertexArrayObject;if((0,b.Wi)(Be))continue;r.bindVAO(Be),Y.setUniformMatrix3fv("u_dvsMat3",ue.transforms.dvs),r.setStencilTestEnabled(!0),r.setStencilFunction(u.wb.GREATER,255,255),r.setStencilWriteMask(0);const At=(performance.now()-g.lastOpacityUpdate)/1e3;Y.setUniform1f("u_time",At),g.glyphPerPageElementsMap.forEach((Ot,zt)=>{this._renderGlyphRange(r,Ot,zt,s,Y,I,R,ue)})}}_renderGlyphRange(e,i,t,n,r,o,a,s){n.bind(e,u.cw.LINEAR,t,te.CU),o&&(r.setUniform1f("u_halo",1),e.drawElements(u.MX.TRIANGLES,i[1],u.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),s.triangleCount+=i[1]/3),a&&(r.setUniform1f("u_halo",0),e.drawElements(u.MX.TRIANGLES,i[1],u.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),s.triangleCount+=i[1]/3)}}};var ne=f(919);const gt={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}},xt=new class vt{constructor(e){this._readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e,i=new Map){if(i.has(e))return i.get(e);const t=this._read(e);if(!t)throw new Error(`cannot find shader file ${e}`);const n=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let r=n.exec(t);const o=[];for(;null!=r;)o.push({path:r[1],start:r.index,length:r[0].length}),r=n.exec(t);let a=0,s="";return o.forEach(l=>{s+=t.slice(a,l.start),s+=i.has(l.path)?"":this._resolve(l.path,i),a=l.start+l.length}),s+=t.slice(a),i.set(e,s),s}_read(e){return this._readFile(e)}}(function yt(d){let e=gt;return d.split("/").forEach(i=>{e&&(e=e[i])}),e});function re(d){return xt.resolveIncludes(d)}function wt(d){const{options:e,value:i}=d;return"number"==typeof e[i]}function he(d){let e="";for(const i in d){const t=d[i];if("boolean"==typeof t)t&&(e+=`#define ${i}\n`);else if("number"==typeof t)e+=`#define ${i} ${t.toFixed()}\n`;else if("object"==typeof t)if(wt(t)){const{value:n,options:r,namespace:o}=t,a=o?`${o}_`:"";for(const s in r)e+=`#define ${a}${s} ${r[s].toFixed()}\n`;e+=`#define ${i} ${a}${n}\n`}else{const n=t.options;let r=0;for(const o in n)e+=`#define ${n[o]} ${(r++).toFixed()}\n`;e+=`#define ${i} ${n[t.value]}\n`}}return e}const Ee=d=>he({ID:d.id,PATTERN:d.pattern}),St={shaders:d=>({vertexShader:Ee(d)+re("background/background.vert"),fragmentShader:Ee(d)+re("background/background.frag")})},Ue=d=>he({ID:d.id}),bt={shaders:d=>({vertexShader:Ue(d)+re("circle/circle.vert"),fragmentShader:Ue(d)+re("circle/circle.frag")})},Le=d=>he({ID:d.id,PATTERN:d.pattern}),Mt={shaders:d=>({vertexShader:Le(d)+re("fill/fill.vert"),fragmentShader:Le(d)+re("fill/fill.frag")})},Ae=d=>he({ID:d.id}),Pt={shaders:d=>({vertexShader:Ae(d)+re("outline/outline.vert"),fragmentShader:Ae(d)+re("outline/outline.frag")})},Oe=d=>he({ID:d.id,SDF:d.sdf}),Tt={shaders:d=>({vertexShader:Oe(d)+re("icon/icon.vert"),fragmentShader:Oe(d)+re("icon/icon.frag")})},ze=d=>he({ID:d.id,PATTERN:d.pattern,SDF:d.sdf}),It={shaders:d=>({vertexShader:ze(d)+re("line/line.vert"),fragmentShader:ze(d)+re("line/line.frag")})},Fe=d=>he({ID:d.id}),Ct={shaders:d=>({vertexShader:Fe(d)+re("text/text.vert"),fragmentShader:Fe(d)+re("text/text.frag")})};class Dt{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach(e=>e.dispose()),this._programByKey.clear()}getMaterialProgram(e,i,t){const n=i.key<<3|this._getMaterialOptionsValue(i.type,t);if(this._programByKey.has(n))return this._programByKey.get(n);const r=this._getProgramTemplate(i.type),{shaders:o}=r,{vertexShader:a,fragmentShader:s}=o(t),l=i.getShaderHeader(),h=i.getShaderMain(),m=a.replace("#pragma header",l).replace("#pragma main",h),_=e.programCache.acquire(m,s,i.getAttributeLocations());return this._programByKey.set(n,_),_}_getMaterialOptionsValue(e,i){switch(e){case ne._K.BACKGROUND:case ne._K.FILL:return(i.pattern?1:0)<<1|(i.id?1:0);case ne._K.OUTLINE:return i.id?1:0;case ne._K.LINE:return(i.sdf?1:0)<<2|(i.pattern?1:0)<<1|(i.id?1:0);case ne._K.ICON:return(i.sdf?1:0)<<1|(i.id?1:0);case ne._K.CIRCLE:case ne._K.TEXT:return i.id?1:0;default:return 0}}_getProgramTemplate(e){switch(e){case ne._K.BACKGROUND:return St;case ne._K.CIRCLE:return bt;case ne._K.FILL:return Mt;case ne._K.ICON:return Tt;case ne._K.LINE:return It;case ne._K.OUTLINE:return Pt;case ne._K.TEXT:return Ct;default:return null}}}class Ne{constructor(e,i){this.spriteMosaic=e,this.glyphMosaic=i,this._brushCache=new Map,this._vtlMaterialManager=new Dt}dispose(){this._brushCache&&(this._brushCache.forEach(e=>e.dispose()),this._brushCache=null),this._vtlMaterialManager=(0,b.M2)(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawTile(e,i,t){const{context:n}=e,r=t.layers;t.backgroundBucketIds.length>0&&(e.renderPass="background",t.backgroundBucketIds.forEach(o=>this._renderStyleLayer(t.getLayerById(o),e,i,!0))),n.setBlendingEnabled(!1),n.setDepthTestEnabled(!0),n.setDepthWriteEnabled(!0),n.setDepthFunction(u.wb.LEQUAL),e.renderPass="opaque";for(let o=r.length-1;o>=0;o--)this._renderStyleLayer(r[o],e,i,!1);n.setDepthWriteEnabled(!1),n.setBlendingEnabled(!0),n.setBlendFunctionSeparate(u.zi.ONE,u.zi.ONE_MINUS_SRC_ALPHA,u.zi.ONE,u.zi.ONE_MINUS_SRC_ALPHA),e.renderPass="translucent";for(let o=0;o<r.length;o++)this._renderStyleLayer(r[o],e,i,!1);n.setDepthTestEnabled(!1),n.bindVAO()}_renderStyleLayer(e,i,t,n=!1){if(!(n||e&&t.layerData.has(e.uid)))return;const r=e.getLayoutProperty("visibility");if(r&&r.getValue()===z.EE.NONE)return;const{renderPass:o}=i;let a;switch(e.type){case z.fR.BACKGROUND:if("background"!==o)return;a="vtlBackground";break;case z.fR.FILL:if("opaque"!==o&&"translucent"!==i.renderPass)return;a="vtlFill";break;case z.fR.LINE:if("translucent"!==o)return;a="vtlLine";break;case z.fR.CIRCLE:if("translucent"!==o)return;a="vtlCircle";break;case z.fR.SYMBOL:if("translucent"!==o)return;a="vtlSymbol"}const s=i.displayLevel;void 0!==e.minzoom&&e.minzoom>s+1e-6||void 0!==e.maxzoom&&e.maxzoom<=s-1e-6||(i.styleLayerUID=e.uid,i.styleLayer=e,this._drawWithBrush(i,t,a))}_drawWithBrush(e,i,t){this._brushCache.has(t)||this._brushCache.set(t,new(0,pt[t])),this._brushCache.get(t).drawMany(e,[i])}}var ke=f(78364),Rt=f(19702),Et=f(50916),We=f(61779),Ut=f(45611);let pe=class extends((0,Et.r)((0,Rt.A)(Ut.Z))){constructor(){super(...arguments),this.type="vector-tile-3d"}initialize(){if((0,b.Wi)(this.layer.fullExtent))return void this.addResolvingPromise(Promise.reject(new X.Z("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:d,spatialReference:e,state:i,viewingMode:t}=this.view,{pixelRatio:n}=i,a="local"===t&&!(0,We.jO)(e)||We.Bu.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getOrCreateCompatible(256,this.layer.tileInfo.spatialReference.isGeographic?1:2),s=this._getTileInfoSupportError(a,this.layer.fullExtent);if((0,b.pC)(s))return this.addResolvingPromise(Promise.reject(s));const l=(0,F.N1)(()=>this.view?.basemapTerrain?.tilingSchemeLocked).then(()=>{const g=d.tilingScheme,L=g.pixelSize;let D;this.schemaHelper=new M(L,(0,b.pC)(d.spatialReference)&&d.spatialReference.isGeographic),D=256===L?this.layer.tileInfo.getOrCreateCompatible(256,this.layer.tileInfo.spatialReference.isGeographic?1:2):this.view.spatialReference.isGeographic?this.layer.tileInfo.getOrCreateCompatible(512,.5):this.layer.tileInfo;const S=this._getTileInfoCompatibilityError(D,g);if(S)throw S;this.tileInfo=D});this._tileHandlerController=new AbortController;const h=this.view.resourceController;this._memCache=h.memoryController.newCache(this.layer.uid,g=>{g.release()});const m=new ke.Z(this.layer.currentStyleInfo.style),_=d.mapTileRequester;this._tileHandler=new Te(this.layer,m,n,this._memCache,_);const c=this._tileHandlerController.signal,v=g=>h.schedule(g),p=this._tileHandler.start({signal:c,schedule:v}),y=this._tileHandler.spriteMosaic;y.then(g=>{!(0,$.Hc)(c)&&this._tileHandler&&(this.painter=new Ne(g,this._tileHandler.glyphMosaic))}),p.then(()=>this._tileHandlerController=null),this.updatingHandles.add(()=>({style:this.layer.currentStyleInfo.style,newPixelRatio:this.view.state?.pixelRatio}),({style:g})=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const L=new ke.Z(g),D=new Te(this.layer,L,n,this._memCache,_),S=D.start({signal:this._tileHandlerController.signal,schedule:v}),R=D.spriteMosaic;S.then(()=>this._tileHandlerController=null),this.updatingHandles.addPromise(Promise.all([S,R]).then(([,T])=>{const P=this._tileHandler,I=this.painter;this.painter=new Ne(T,D.glyphMosaic),this._tileHandler=D,this.emit("data-changed"),P.destroy(),I&&I.dispose()}))});const x=Promise.all([l,p,y]);this.addResolvingPromise(x)}destroy(){this.painter=(0,b.M2)(this.painter),this._tileHandlerController&&(this._tileHandlerController.abort(),this._tileHandlerController=null),(0,b.SC)(this._tileHandler),this._memCache=(0,b.SC)(this._memCache),this._tileHandler=null}get dataLevelRange(){const d=this.tileInfo.lods,t=this.levelRangeFromScaleRange(d[0].scale,d[d.length-1].scale);return 1===t.minLevel&&256===this.tileInfo.size[0]&&(t.minLevel=0),t}fetchTile(d,e,i,t){var n=this;return(0,W.Z)(function*(){return n._tileHandler.getVectorTile(d,e,i,t)})()}};(0,G._)([(0,V.Cb)()],pe.prototype,"layer",void 0),(0,G._)([(0,V.Cb)()],pe.prototype,"dataLevelRange",null),(0,G._)([(0,V.Cb)()],pe.prototype,"updatingProgressValue",void 0),pe=(0,G._)([(0,N.j)("esri.views.3d.layers.VectorTileLayerView3D")],pe);const Lt=pe},45611:(de,ee,f)=>{f.d(ee,{Z:()=>U});var W=f(17626),G=f(14517),X=f(61885),b=f(80542),$=f(61996),F=f(63290),V=f(62208),oe=f(60330),J=f(77712),E=(f(85931),f(90912),f(76898));let B=class extends((0,b.p)((0,$.IG)((0,oe.v)(X.Z.EventedMixin(G.Z))))){constructor(A){super(A),this.layer=null,this.parent=null}initialize(){this.when().catch(A=>{if("layerview:create-error"!==A.name){const j=this.layer&&this.layer.id||"no id",Z=this.layer&&this.layer.title||"no title";F.Z.getLogger(this.declaredClass).error("#resolve()",`Failed to resolve layer view (layer title: '${Z}', id: '${j}')`,A)}})}get fullOpacity(){return(0,V.Pt)(this.get("layer.opacity"),1)*(0,V.Pt)(this.get("parent.fullOpacity"),1)}get suspended(){return!this.canResume()}get suspendInfo(){return this.getSuspendInfo()}get legendEnabled(){return!this.suspended&&!0===this.layer?.legendEnabled}get updating(){return!(!this.updatingHandles?.updating&&!this.isUpdating())}get updatingProgress(){return this.updating?0:1}get visible(){return!0===this.layer?.visible}set visible(A){this._overrideIfSome("visible",A)}canResume(){return this.visible&&this.layer?.loaded&&!this.parent?.suspended&&this.view?.ready||!1}getSuspendInfo(){const A=this.parent&&this.parent.suspended?this.parent.suspendInfo:{};return this.view&&this.view.ready||(A.viewNotReady=!0),this.layer&&this.layer.loaded||(A.layerNotLoaded=!0),this.visible||(A.layerInvisible=!0),A}isUpdating(){return!1}};(0,W._)([(0,J.Cb)()],B.prototype,"fullOpacity",null),(0,W._)([(0,J.Cb)()],B.prototype,"layer",void 0),(0,W._)([(0,J.Cb)()],B.prototype,"parent",void 0),(0,W._)([(0,J.Cb)({readOnly:!0})],B.prototype,"suspended",null),(0,W._)([(0,J.Cb)({readOnly:!0})],B.prototype,"suspendInfo",null),(0,W._)([(0,J.Cb)({readOnly:!0})],B.prototype,"legendEnabled",null),(0,W._)([(0,J.Cb)({type:Boolean,readOnly:!0})],B.prototype,"updating",null),(0,W._)([(0,J.Cb)({readOnly:!0})],B.prototype,"updatingProgress",null),(0,W._)([(0,J.Cb)()],B.prototype,"visible",null),(0,W._)([(0,J.Cb)()],B.prototype,"view",void 0),B=(0,W._)([(0,E.j)("esri.views.layers.LayerView")],B);const U=B}}]);