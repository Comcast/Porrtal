"use strict";(self.webpackChunka_porrtal_io_app=self.webpackChunka_porrtal_io_app||[]).push([[2579],{42579:(Ue,dt,l)=>{l.r(dt),l.d(dt,{meshFeatureSetFromJSON:()=>Pe});var zt=l(88879),p=l(62208),st=l(2004),U=l(15861),M=l(17626),it=l(26584),Dt=l(80542),Nt=l(47996),V=l(63290),jt=l(60330),j=l(10699),Gt=l(32917),Z=l(77712),$t=(l(85931),l(8314),l(90912),l(76898)),d=l(28093),Bt=l(21674),S=l(49672),Wt=l(37118),A=l(89586),G=l(61751),q=l(99746),_=l(92529),Ht=l(85334),I=l(55915),tt=l(92545),at=l(60853);const lt=V.Z.getLogger("esri.geometry.support.meshUtils.centerAt");const Vt=(0,d.c)(),kt=(0,d.c)();var xt=l(21726);function ct(){return(ct=(0,U.Z)(function*(t,n,e){const{loadGLTFMesh:r}=yield(0,j.Hl)(l.e(9185).then(l.bind(l,29185)),e),o=yield vt(n,e),s=r(new S.Z({x:0,y:0,z:0,spatialReference:t.spatialReference}),o.url,{resolveFile:_t(o),useTransform:!0,signal:(0,p.pC)(e)?e.signal:null});s.then(()=>o.dispose(),()=>o.dispose());const{vertexAttributes:i,components:a}=yield s;t.vertexAttributes=i,t.components=a})).apply(this,arguments)}function _t(t){const n=(0,xt.Yd)(t.url);return e=>{const r=(0,xt.PF)(e,n,n),o=r?r.replace(/^ *\.\//,""):null;return t.files.get(o)??e}}function vt(t,n){return ft.apply(this,arguments)}function ft(){return(ft=(0,U.Z)(function*(t,n){return t instanceof Blob?$.fromBlob(t):"string"==typeof t?new $(t):Array.isArray(t)?te(t,n):ee(t,n)})).apply(this,arguments)}function te(t,n){return pt.apply(this,arguments)}function pt(){return pt=(0,U.Z)(function*(t,n){const e=new Map;let r=null;const o=yield(0,j.WW)(t.map(function(){var i=(0,U.Z)(function*(a){return{name:a.name,source:yield vt(a instanceof Blob?a:a.source,n)}});return function(a){return i.apply(this,arguments)}}())),s=[];for(const i of o)i&&((0,j.Hc)(n)?i.source.dispose():s.push(i));(0,j.k_)(n);for(const{name:i,source:a}of s)((0,p.Wi)(r)||/\.(gltf|glb)/i.test(i))&&(r=a.url),e.set(i,a.url),a.files&&a.files.forEach((f,c)=>e.set(c,f));if((0,p.Wi)(r))throw new it.Z("mesh-load-external:missing-files","Missing files to load external mesh source");return new $(r,()=>s.forEach(({source:i})=>i.dispose()),e)}),pt.apply(this,arguments)}function ee(t,n){return ut.apply(this,arguments)}function ut(){return ut=(0,U.Z)(function*(t,n){const{default:e}=yield(0,j.Hl)(Promise.resolve().then(l.bind(l,84792)),n),r="string"==typeof t.multipart[0]?yield Promise.all(t.multipart.map(function(){var o=(0,U.Z)(function*(s){return(yield e(s,{responseType:"array-buffer"})).data});return function(s){return o.apply(this,arguments)}}())):t.multipart;return $.fromBlob(new Blob(r))}),ut.apply(this,arguments)}class ${constructor(n,e=(()=>{}),r=new Map){this.url=n,this.dispose=e,this.files=r}static fromBlob(n){const e=URL.createObjectURL(n);return new $(e,()=>URL.revokeObjectURL(e))}}var yt=l(30217),ht=l(550),At=l(43703),y=l(84161),mt=l(12080),v=l(65231);const ne=V.Z.getLogger("esri.geometry.support.meshUtils.offset");function Ct(t,n){if(t)for(let e=0;e<t.length;e+=3)for(let r=0;r<3;r++)t[e+r]+=n[r]}const ae=(0,d.c)(),bt=(0,At.c)(),wt=(0,ht.c)(),k={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function et(t,n,e){t.isPlane||function me(t){for(let n=0;n<t.position.length;n+=3)t.position[n+2]+=.5}(t),function ge(t,n){if(null==n)return;const e="number"==typeof n?[n,n,n]:[null!=n.width?n.width:1,null!=n.depth?n.depth:1,null!=n.height?n.height:1];T[0]=e[0],T[4]=e[1],T[8]=e[2];for(let r=0;r<t.position.length;r+=3){for(let o=0;o<3;o++)x[o]=t.position[r+o];(0,y.t)(x,x,T);for(let o=0;o<3;o++)t.position[r+o]=x[o]}if(e[0]!==e[1]||e[1]!==e[2]){T[0]=1/e[0],T[4]=1/e[1],T[8]=1/e[2];for(let r=0;r<t.normal.length;r+=3){for(let o=0;o<3;o++)x[o]=t.normal[r+o];(0,y.t)(x,x,T),(0,y.n)(x,x);for(let o=0;o<3;o++)t.normal[r+o]=x[o]}}}(t,e&&e.size);const{vertexAttributes:r,transform:o}=(0,at.w1)(t,n,e);return{vertexAttributes:new _.Q({...r,uv:t.uv}),transform:o,components:[new G.Z({faces:t.faces,material:e&&e.material||null})],spatialReference:n.spatialReference}}const de={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},xe={south:0,east:1,north:2,west:3,up:4,down:5},x=(0,d.c)(),T=(0,ht.c)();var ve=l(28347);const Ft=V.Z.getLogger("esri.geometry.support.meshUtils.rotate");function Y(t,n,e,r=d.Z){if(!(0,p.Wi)(t)){(0,ve.d)(nt,(0,A.WH)(n),(0,A.ZZ)(n));for(let o=0;o<t.length;o+=e){for(let s=0;s<3;s++)K[s]=t[o+s]-r[s];(0,y.m)(K,K,nt);for(let s=0;s<3;s++)t[o+s]=K[s]+r[s]}}}const K=(0,d.c)(),Mt=(0,d.c)(),Rt=(0,A.Ue)(),nt=(0,At.c)(),Zt=(0,ht.c)(),Pt=(0,d.c)(),Et=V.Z.getLogger("esri.geometry.support.meshUtils.scale");function Ot(t,n,e=d.Z){if(t)for(let r=0;r<t.length;r+=3){for(let o=0;o<3;o++)X[o]=t[r+o]-e[o];(0,y.g)(X,X,n);for(let o=0;o<3;o++)t[r+o]=X[o]+e[o]}}const X=(0,d.c)(),St=(0,d.c)(),It=(0,d.c)();var P;const R=V.Z.getLogger("esri.geometry.Mesh");let b=P=class extends((0,Dt.p)(Nt.Z.LoadableMixin((0,jt.v)(Bt.Z)))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new _.Q,this.type="mesh"}initialize(){((0,p.Wi)(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.handles.add((0,Gt.YP)(()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map(t=>t.clone()),transform:(0,p.pC)(this.transform)?this.transform.clone():null}),()=>this._set("external",null),{once:!0,sync:!0}))})}get hasExtent(){return!this.loaded&&(0,p.pC)(this.external)&&(0,p.pC)(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const t=this.vertexAttributes.position,n=this.spatialReference;if(0===t.length||this.components&&0===this.components.length)return{extent:new st.Z({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:n}),center:new S.Z({x:0,y:0,z:0,spatialReference:n})};const e=(0,p.pC)(this.transform)?this.transform.project(t,n):t;let r=1/0,o=1/0,s=1/0,i=-1/0,a=-1/0,f=-1/0,c=0,u=0,g=0;const m=e.length,h=1/(m/3);let w=0;for(;w<m;){const L=e[w++],C=e[w++],E=e[w++];r=Math.min(r,L),o=Math.min(o,C),s=Math.min(s,E),i=Math.max(i,L),a=Math.max(a,C),f=Math.max(f,E),c+=h*L,u+=h*C,g+=h*E}return{extent:new st.Z({xmin:r,ymin:o,zmin:s,xmax:i,ymax:a,zmax:f,spatialReference:n}),center:new S.Z({x:c,y:u,z:g,spatialReference:n})}}get anchor(){if((0,p.pC)(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this.boundingInfo;return new S.Z({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return(0,p.pC)(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&(0,p.pC)(this.external)&&(0,p.pC)(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push(G.Z.from(t)),this.notifyChange("components")):R.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const n=this.components.indexOf(t);if(-1!==n)return this.components.splice(n,1),void this.notifyChange("components")}R.error("removeComponent()","Provided component is not part of the list of components")}else R.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,n,e,r){return(0,A.uT)(gt.x,t,J),(0,A.uT)(gt.y,n,Lt),(0,A.uT)(gt.z,e,Ut),(0,A.qC)(J,Lt,J),(0,A.qC)(J,Ut,J),function ye(t,n,e){if(!t.vertexAttributes||!t.vertexAttributes.position||0===n[3])return;const r=t.spatialReference;if((0,p.pC)(t.transform)){null!=e?.geographic&&e.geographic!==t.transform.geographic&&Ft.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=e?.origin??t.transform.getOriginPoint(r);!function Ae(t,n,e){const r=(0,y.s)(K,e.x,e.y,e.z),o=(0,y.b)(K,r,t.origin);t.applyLocalInverse(o,Mt),t.rotation=(0,A.qC)(t.rotation,n,(0,A.Ue)()),t.applyLocalInverse(o,o),(0,y.b)(o,o,Mt),t.translation=(0,y.a)((0,d.c)(),t.translation,o)}(t.transform,n,o)}else{const o=e?.origin??t.origin;(0,tt.h)(t.spatialReference,e)?function Ce(t,n,e){const r=t.spatialReference,o=(0,mt.rS)(r),s=Pt;(0,I.KC)(e,s,o)||(0,I.KC)(t.origin,s,o);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,f=t.vertexAttributes.tangent,c=new Float64Array(i.length),u=(0,p.pC)(a)?new Float32Array(a.length):null,g=(0,p.pC)(f)?new Float32Array(f.length):null;(0,I.Bm)(o,s,nt,o),(0,yt.f)(Zt,nt);const m=Rt;(0,y.t)((0,A.ZZ)(Rt),(0,A.ZZ)(n),Zt),m[3]=n[3],(0,v.XO)(i,r,c),(0,p.pC)(a)&&(0,v.Iz)(a,i,c,r,u),(0,p.pC)(f)&&(0,v.wi)(f,i,c,r,g),Y(c,m,3,s),(0,v.To)(c,i,r),(0,p.pC)(a)&&(Y(u,m,3),(0,v.Yk)(u,i,c,r,a)),(0,p.pC)(f)&&(Y(g,m,4),(0,v.M2)(g,i,c,r,f)),t.vertexAttributesChanged()}(t,n,o):function be(t,n,e){const r=Pt;if(!(0,I.KC)(e,r,t.spatialReference)){const o=t.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,Ft.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Y(t.vertexAttributes.position,n,3,r),Y(t.vertexAttributes.normal,n,3),Y(t.vertexAttributes.tangent,n,4),t.vertexAttributesChanged()}(t,n,o)}}(this,J,r),this}offset(t,n,e,r){return this.loaded?(rt[0]=t,rt[1]=n,rt[2]=e,function re(t,n,e){t.vertexAttributes&&t.vertexAttributes.position&&((0,p.pC)(t.transform)?(null!=e?.geographic&&e.geographic!==t.transform.geographic&&ne.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function oe(t,n){const e=t.origin;t.origin=(0,y.a)((0,d.c)(),e,n)}(t.transform,n)):(0,tt.h)(t.spatialReference,e)?function se(t,n){const e=t.spatialReference,r=t.vertexAttributes.position,o=t.vertexAttributes.normal,s=t.vertexAttributes.tangent,i=new Float64Array(r.length),a=(0,p.pC)(o)?new Float32Array(o.length):null,f=(0,p.pC)(s)?new Float32Array(s.length):null,c=t.extent.center,u=ae;(0,I.Bm)(e,[c.x,c.y,c.z],bt,(0,mt.rS)(e)),(0,yt.f)(wt,bt),(0,y.t)(u,n,wt),(0,v.XO)(r,e,i),(0,p.pC)(o)&&(0,v.Iz)(o,r,i,e,a),(0,p.pC)(s)&&(0,v.wi)(s,r,i,e,f),Ct(i,u),(0,v.To)(i,r,e),(0,p.pC)(o)&&(0,v.Yk)(a,r,i,e,o),(0,p.pC)(s)&&(0,v.M2)(f,r,i,e,s),t.vertexAttributesChanged()}(t,n):function ie(t,n){Ct(t.vertexAttributes.position,n),t.vertexAttributesChanged()}(t,n))}(this,rt,r),this):(R.error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,n){return this.loaded?(function we(t,n,e){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=t.spatialReference;if((0,p.pC)(t.transform)){null!=e?.geographic&&e.geographic!==t.transform.geographic&&Et.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const o=e?.origin??t.transform.getOriginPoint(r);!function Fe(t,n,e){const r=(0,y.s)(X,e.x,e.y,e.z),o=(0,y.b)(X,r,t.origin);t.applyLocalInverse(o,St);const s=(0,y.g)((0,d.c)(),t.scale,n);t.scale=s,t.applyLocalInverse(o,o),(0,y.b)(o,o,St),t.translation=(0,y.a)((0,d.c)(),t.translation,o)}(t.transform,n,o)}else{const o=(0,tt.h)(t.spatialReference,e),s=e&&e.origin||t.origin;o?function Me(t,n,e){const r=t.spatialReference,o=(0,mt.rS)(r),s=It;(0,I.KC)(e,s,o)||(0,I.KC)(t.origin,s,o);const i=t.vertexAttributes.position,a=t.vertexAttributes.normal,f=t.vertexAttributes.tangent,c=new Float64Array(i.length),u=(0,p.pC)(a)?new Float32Array(a.length):null,g=(0,p.pC)(f)?new Float32Array(f.length):null;(0,v.XO)(i,r,c),(0,p.pC)(a)&&(0,v.Iz)(a,i,c,r,u),(0,p.pC)(f)&&(0,v.wi)(f,i,c,r,g),Ot(c,n,s),(0,v.To)(c,i,r),(0,p.pC)(a)&&(0,v.Yk)(u,i,c,r,a),(0,p.pC)(f)&&(0,v.M2)(g,i,c,r,f),t.vertexAttributesChanged()}(t,n,s):function Re(t,n,e){const r=It;if(!(0,I.KC)(e,r,t.spatialReference)){const o=t.origin;r[0]=o.x,r[1]=o.y,r[2]=o.z,Et.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Ot(t.vertexAttributes.position,n,r),t.vertexAttributesChanged()}(t,n,s)}}(this,t,n),this):(R.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,n){return this.loaded?(function Yt(t,n,e){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const r=e?.origin??t.origin;(0,p.pC)(t.transform)?(null!=e?.geographic&&e.geographic!==t.transform.geographic&&lt.warn(`Specifying the 'geographic' parameter (${e.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function Kt(t,n,e){const i=t.origin;t.origin=[i[0]+(n.x-e.x),i[1]+(n.y-e.y),i[2]+(n.hasZ&&e.hasZ?n.z-e.z:0)]}(t.transform,n,r)):(0,tt.h)(t.spatialReference,e)?function Xt(t,n,e){const r=(0,at.FF)(t.vertexAttributes,e,{geographic:!0}),{position:o,normal:s,tangent:i}=(0,at.iv)(r,n,{geographic:!0});t.vertexAttributes.position=o,t.vertexAttributes.normal=s,t.vertexAttributes.tangent=i,t.vertexAttributesChanged()}(t,n,r):function Jt(t,n,e){const r=kt,o=Vt;if((0,I.KC)(n,o,t.spatialReference)){if(!(0,I.KC)(e,r,t.spatialReference)){const s=t.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,lt.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}(function Qt(t,n,e){if(t)for(let r=0;r<t.length;r+=3)for(let o=0;o<3;o++)t[r+o]+=n[o]-e[o]})(t.vertexAttributes.position,o,r),t.vertexAttributesChanged()}else lt.error(`Failed to project centerAt location (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`)}(t,n,r)}(this,t,n),this):(R.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return(0,p.pC)(this.external)&&this.addResolvingPromise(function qt(t,n,e){return ct.apply(this,arguments)}(this,this.external.source,t)),Promise.resolve(this)}clone(){const t=this.components?new Map:null,n=this.components?new Map:null,e={components:this.components?this.components.map(r=>r.cloneWithDeduplication(t,n)):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:(0,p.pC)(this.transform)?this.transform.clone():null,external:(0,p.pC)(this.external)?{source:this.external.source,extent:(0,p.pC)(this.external.extent)?this.external.extent.clone():null}:null};return new P(e)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}toBinaryGLTF(t){var n=this;return(0,U.Z)(function*(){const{toBinaryGLTF:e}=yield l.e(7627).then(l.bind(l,57627));return e(n,t)})()}static createBox(t,n){if(!(t instanceof S.Z))return R.error(".createBox()","expected location to be a Point instance"),null;const e=new P(et(function le(){const{faceDescriptions:t,faceVertexOffsets:n,uvScales:e}=de,r=4*t.length,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(2*t.length*3);let f=0,c=0,u=0,g=0;for(let m=0;m<t.length;m++){const h=t[m],w=f/3;for(const C of n)a[g++]=w+C;const L=h.corners;for(let C=0;C<4;C++){const E=L[C];let F=0;i[u++]=.25*e[C][0]+h.uvOrigin[0],i[u++]=h.uvOrigin[1]-.25*e[C][1];for(let O=0;O<3;O++)0!==h.axis[O]?(o[f++]=.5*h.axis[O],s[c++]=h.axis[O]):(o[f++]=.5*E[F++],s[c++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),t,n));return n&&n.imageFace&&"all"!==n.imageFace?function ce(t,n){const e=t.components[0],r=e.faces,o=xe[n],s=6*o,i=new Uint32Array(6),a=new Uint32Array(r.length-6);let f=0,c=0;for(let u=0;u<r.length;u++)u>=s&&u<s+6?i[f++]=r[u]:a[c++]=r[u];if((0,p.pC)(t.vertexAttributes.uv)){const u=new Float32Array(t.vertexAttributes.uv),g=4*o*2,m=[0,1,1,1,1,0,0,0];for(let h=0;h<m.length;h++)u[g+h]=m[h];t.vertexAttributes.uv=u}return t.components=[new G.Z({faces:i,material:e.material}),new G.Z({faces:a})],t}(e,n.imageFace):e}static createSphere(t,n){return t instanceof S.Z?new P(et(function fe(t=0){const n=Math.round(8*2**t),e=2*n,r=(n-1)*(e+1)+2*e,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array((n-1)*e*2*3);let f=0,c=0,u=0,g=0;for(let m=0;m<=n;m++){const h=m/n*Math.PI+.5*Math.PI,w=Math.cos(h),L=Math.sin(h);x[2]=L;const C=0===m||m===n,E=C?e-1:e;for(let F=0;F<=E;F++){const O=F/E*2*Math.PI;x[0]=-Math.sin(O)*w,x[1]=Math.cos(O)*w;for(let D=0;D<3;D++)o[f]=.5*x[D],s[f]=x[D],++f;i[c++]=(F+(C?.5:0))/e,i[c++]=m/n,0!==m&&F!==e&&(m!==n&&(a[u++]=g,a[u++]=g+1,a[u++]=g-e),1!==m&&(a[u++]=g,a[u++]=g-e,a[u++]=g-e-1)),g++}}return{position:o,normal:s,uv:i,faces:a}}(n&&n.densificationFactor||0),t,n)):(R.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,n){return t instanceof S.Z?new P(et(function pe(t=0){const e=Math.round(16*2**t),r=4*(e+1)+2*e,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(4*e*3);let f=0,c=0,u=0,g=0,m=0;for(let h=0;h<=5;h++){const w=0===h||5===h,L=h<=1||h>=4,C=2===h||4===h,E=w?e-1:e;for(let F=0;F<=E;F++){const O=F/E*2*Math.PI,D=w?0:.5;x[0]=D*Math.sin(O),x[1]=D*-Math.cos(O),x[2]=h<=2?.5:-.5;for(let Q=0;Q<3;Q++)o[f++]=x[Q],s[c++]=L?2===Q?h<=1?1:-1:0:2===Q?0:x[Q]/D;i[u++]=(F+(w?.5:0))/e,i[u++]=h<=1?1*h/3:h<=3?1*(h-2)/3+1/3:1*(h-4)/3+2/3,C||0===h||F===e||(5!==h&&(a[g++]=m,a[g++]=m+1,a[g++]=m-e),1!==h&&(a[g++]=m,a[g++]=m-e,a[g++]=m-e-1)),m++}}return{position:o,normal:s,uv:i,faces:a}}(n&&n.densificationFactor||0),t,n)):(R.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,n){if(!(t instanceof S.Z))return R.error(".createPlane()","expected location to be a Point instance"),null;const e=n?.facing??"up",r=function ue(t,n){const e="number"==typeof n?n:null!=n?n.width:1,r="number"==typeof n?n:null!=n?n.height:1;switch(t){case"up":case"down":return{width:e,depth:r};case"north":case"south":return{width:e,height:r};case"east":case"west":return{depth:e,height:r}}}(e,n?.size);return new P(et(function he(t){const n=k.facingAxisOrderSwap[t],e=k.position,r=k.normal,o=new Float64Array(e.length),s=new Float32Array(r.length);let i=0;for(let a=0;a<4;a++){const f=i;for(let c=0;c<3;c++){const u=n[c],g=Math.abs(u)-1,m=u>=0?1:-1;o[i]=e[f+g]*m,s[i]=r[f+g]*m,i++}}return{position:o,normal:s,uv:new Float32Array(k.uv),faces:new Uint32Array(k.faces),isPlane:!0}}(e),t,{...n,size:r}))}static createFromPolygon(t,n){if(!(t instanceof Wt.Z))return R.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const e=(0,Ht.bT)(t);return new P({vertexAttributes:new _.Q({position:e.position}),components:[new G.Z({faces:e.faces,shading:"flat",material:n&&n.material||null})],spatialReference:t.spatialReference})}static createFromGLTF(t,n,e){return(0,U.Z)(function*(){if(!(t instanceof S.Z))throw R.error(".createfromGLTF()","expected location to be a Point instance"),new it.Z("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=yield(0,j.Hl)(l.e(9185).then(l.bind(l,29185)),e);return new P(yield r(t,n,e))})()}static createWithExternalSource(t,n,e){const r=e?.extent??null,o=e?.transform.clone()??new q.Z;return o.origin=[t.x,t.y,t.z??0],new P({external:{source:n,extent:r},transform:o,spatialReference:t.spatialReference})}static createIncomplete(t,n){const e=n?.transform.clone()??new q.Z;e.origin=[t.x,t.y,t.z??0];const o=new P({transform:e,spatialReference:t.spatialReference});return o.addResolvingPromise(Promise.reject(new it.Z("mesh-incomplete","Mesh resources are not complete"))),o}};(0,M._)([(0,Z.Cb)({type:[G.Z],json:{write:!0}})],b.prototype,"components",void 0),(0,M._)([(0,Z.Cb)({type:q.Z,json:{write:!0}})],b.prototype,"transform",void 0),(0,M._)([(0,Z.Cb)({constructOnly:!0})],b.prototype,"external",void 0),(0,M._)([(0,Z.Cb)({readOnly:!0})],b.prototype,"hasExtent",null),(0,M._)([(0,Z.Cb)({readOnly:!0})],b.prototype,"boundingInfo",null),(0,M._)([(0,Z.Cb)({readOnly:!0})],b.prototype,"anchor",null),(0,M._)([(0,Z.Cb)({readOnly:!0})],b.prototype,"origin",null),(0,M._)([(0,Z.Cb)({readOnly:!0,json:{read:!1}})],b.prototype,"extent",null),(0,M._)([(0,Z.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!0}})],b.prototype,"hasZ",void 0),(0,M._)([(0,Z.Cb)({readOnly:!0,json:{read:!1,write:!0,default:!1}})],b.prototype,"hasM",void 0),(0,M._)([(0,Z.Cb)({type:_.Q,nonNullable:!0,json:{write:!0}})],b.prototype,"vertexAttributes",void 0),b=P=(0,M._)([(0,$t.j)("esri.geometry.Mesh")],b);const gt={x:(0,d.f)(1,0,0),y:(0,d.f)(0,1,0),z:(0,d.f)(0,0,1)},J=(0,A.Ue)(),Lt=(0,A.Ue)(),Ut=(0,A.Ue)(),rt=(0,d.c)(),Tt=b;var N,ot,t;(t=N||(N={})).featureGUID="featureGUID",t.assetName="assetName",t.hash="hash",t.type="type",t.conversionStatus="conversionStatus",t.flags="flags",t.complexity="complexity",t.size="size",t.seqNo="seqNo",t.sourceHash="sourceHash",t.assetURL="assetURL",function(t){t.SUBMITTED="SUBMITTED",t.INPROGRESS="INPROGRESS",t.FAILED="FAILED",t.COMPLETED="COMPLETED"}(ot||(ot={}));var z,Ze=l(17253);function Pe(t,n,e){const r=e.features;e.features=[],delete e.geometryType;const o=Ze.default.fromJSON(e);o.geometryType="mesh";const s=o.spatialReference,i=(0,p.Wi)(t.outFields)||!t.outFields.length?()=>({}):function Ee(t){return({attributes:n})=>{if(!n)return{};if(!t)return n;for(const e in n)t.has(e)||delete n[e];return n}}(t.outFields.includes("*")?null:new Set(t.outFields));for(const a of r){const f=Oe(a,s,n);(0,p.pC)(f)&&o.features.push(new zt.Z({geometry:f,attributes:i(a)}))}return o}function Oe(t,n,e){const{status:r,source:o}=function Le(t){if(!t.assetMappings)return{status:z.FAILED};const n=[],e=new Map;for(const r of t.assetMappings){const o=r[N.seqNo],s=r[N.assetName],i=r[N.assetURL],a=r[N.conversionStatus];if(a===ot.FAILED)return{status:z.FAILED};if(a!==ot.COMPLETED)return{status:z.PENDING};if(null==o)n.push({name:s,source:i});else{const f=e.get(s);let c;f?c=f.multipart:(c=[],n.push({name:s,source:{multipart:c}}),e.set(s,{multipart:c})),c[o]=i}}return{status:z.COMPLETED,source:n}}(t);if(r===z.FAILED)return null;const s=function Se({attributes:t},n,{transformFieldRoles:e}){return new S.Z({x:t[e.originX],y:t[e.originY],z:t[e.originZ],spatialReference:n})}(t,n,e),i=st.Z.fromJSON(t.geometry);i.spatialReference=n;const a=function Ie({attributes:t,assetMappings:n},{transformFieldRoles:e}){return new q.Z({translation:[t[e.translationX],t[e.translationY],t[e.translationZ]],rotation:(0,A.uT)([t[e.rotationX],t[e.rotationY],t[e.rotationZ]],t[e.rotationDeg]),scale:[t[e.scaleX],t[e.scaleY],t[e.scaleZ]],geographic:!n[N.flags]?.includes("PROJECT_VERTICES")})}(t,e);return r===z.PENDING?Tt.createIncomplete(s,{extent:i,transform:a}):Tt.createWithExternalSource(s,o,{extent:i,transform:a})}!function(t){t[t.FAILED=0]="FAILED",t[t.PENDING=1]="PENDING",t[t.COMPLETED=2]="COMPLETED"}(z||(z={}))}}]);